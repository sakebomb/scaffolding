#!/usr/bin/env bash
# =============================================================================
# scaffold â€” Project initializer for Claude Code
# =============================================================================
# Sets up a project optimized for Claude Code with:
#   - CLAUDE.md agent constitution + language-specific conventions
#   - .claude/ settings, skills (slash commands), and hooks
#   - Tiered test structure + Makefile
#   - Task management (todo, lessons, tests)
#   - Agent specifications
#   - Optional Ralph Wiggum autonomous loop
#
# Usage:
#   ./scaffold                  Interactive setup
#   ./scaffold --help           Show help
#   ./scaffold --keep           Don't remove scaffold artifacts after init
#   ./scaffold --non-interactive Use defaults for all prompts
# =============================================================================
set -euo pipefail

# ---------------------------------------------------------------------------
# Globals
# ---------------------------------------------------------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
KEEP_ARTIFACTS=false
NON_INTERACTIVE=false
PROJECT_NAME=""
PROJECT_DESC=""
LANGUAGE=""
ENABLE_RALPH=false
GIT_REMOTE=""
ALLOW_COMMIT=false
ALLOW_PUSH=false
ALLOW_PKG_MANAGER=false
ALLOW_DOCKER=false
SETUP_LABELS=false
SETUP_KANBAN=false
ENABLE_DOCKER=false

# Colors (disabled if not a terminal)
if [[ -t 1 ]]; then
  BOLD='\033[1m'
  DIM='\033[2m'
  GREEN='\033[0;32m'
  YELLOW='\033[0;33m'
  CYAN='\033[0;36m'
  RED='\033[0;31m'
  RESET='\033[0m'
else
  BOLD='' DIM='' GREEN='' YELLOW='' CYAN='' RED='' RESET=''
fi

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
info()    { echo -e "${CYAN}â–¸${RESET} $*"; }
success() { echo -e "${GREEN}âœ“${RESET} $*"; }
warn()    { echo -e "${YELLOW}âš ${RESET} $*"; }
error()   { echo -e "${RED}âœ—${RESET} $*" >&2; }
header()  { echo -e "\n${BOLD}â•â•â• $* â•â•â•${RESET}\n"; }

# Escape string for use as sed replacement (handles /, &, \, newlines)
sed_escape() {
  printf '%s' "$1" | sed -e 's/[\/&\\]/\\&/g'
}

prompt() {
  local var_name="$1" prompt_text="$2" default="$3"
  if [[ "$NON_INTERACTIVE" == true ]]; then
    printf -v "$var_name" '%s' "$default"
    return
  fi
  local display_default=""
  if [[ -n "$default" ]]; then
    display_default=" ${DIM}[$default]${RESET}"
  fi
  echo -ne "${CYAN}?${RESET} ${prompt_text}${display_default}: "
  local input
  read -r input
  if [[ -z "$input" ]]; then
    printf -v "$var_name" '%s' "$default"
  else
    printf -v "$var_name" '%s' "$input"
  fi
}

prompt_yn() {
  local var_name="$1" prompt_text="$2" default="$3"
  if [[ "$NON_INTERACTIVE" == true ]]; then
    printf -v "$var_name" '%s' "$default"
    return
  fi
  local yn_hint="y/n"
  if [[ "$default" == true ]]; then yn_hint="Y/n"; fi
  if [[ "$default" == false ]]; then yn_hint="y/N"; fi
  echo -ne "${CYAN}?${RESET} ${prompt_text} ${DIM}[$yn_hint]${RESET}: "
  local input
  read -r input
  case "${input,,}" in
    y|yes) printf -v "$var_name" '%s' "true" ;;
    n|no)  printf -v "$var_name" '%s' "false" ;;
    *)     printf -v "$var_name" '%s' "$default" ;;
  esac
}

prompt_choice() {
  local var_name="$1" prompt_text="$2"
  shift 2
  local options=("$@")

  if [[ "$NON_INTERACTIVE" == true ]]; then
    printf -v "$var_name" '%s' "${options[0]}"
    return
  fi

  echo -e "${CYAN}?${RESET} ${prompt_text}"
  local i=1
  for opt in "${options[@]}"; do
    echo -e "  ${BOLD}$i)${RESET} $opt"
    i=$((i + 1))
  done
  echo -ne "${DIM}  Enter number [1]: ${RESET}"
  local input
  read -r input
  if [[ -z "$input" || "$input" -lt 1 || "$input" -gt ${#options[@]} ]] 2>/dev/null; then
    printf -v "$var_name" '%s' "${options[0]}"
  else
    printf -v "$var_name" '%s' "${options[$((input - 1))]}"
  fi
}

# ---------------------------------------------------------------------------
# Parse CLI flags
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
# Update mode â€” pull latest skills, agents, hooks from scaffold repo
# ---------------------------------------------------------------------------
SCAFFOLD_REPO="https://raw.githubusercontent.com/sakebomb/scaffold/main"

run_update() {
  header "Scaffold Update"

  info "Checking for updates from scaffold repo..."
  echo ""

  if ! command -v curl &>/dev/null; then
    error "curl is required for updates. Install it and try again."
    exit 1
  fi

  # Directories to update
  local update_dirs=(".claude/skills" ".claude/hooks" "agents")
  local update_files=()
  local changed=0

  # Discover files to update
  for dir in "${update_dirs[@]}"; do
    if [[ ! -d "$SCRIPT_DIR/$dir" ]]; then
      info "Skipping $dir (directory not found)"
      continue
    fi
    while IFS= read -r -d '' file; do
      local rel_path="${file#"$SCRIPT_DIR"/}"
      update_files+=("$rel_path")
    done < <(find "$SCRIPT_DIR/$dir" -type f -name "*.md" -o -name "*.sh" -o -name "*.json" -print0 2>/dev/null | sort -z)
  done

  # Check each file for changes
  local tmp_dir
  tmp_dir="$(mktemp -d)"
  trap 'rm -rf "$tmp_dir"' EXIT

  for rel_path in "${update_files[@]}"; do
    local url="$SCAFFOLD_REPO/$rel_path"
    local tmp_file="$tmp_dir/$rel_path"
    mkdir -p "$(dirname "$tmp_file")"

    if curl -sf "$url" -o "$tmp_file" 2>/dev/null; then
      if [[ -f "$SCRIPT_DIR/$rel_path" ]]; then
        if ! diff -q "$SCRIPT_DIR/$rel_path" "$tmp_file" &>/dev/null; then
          changed=$((changed + 1))
          echo -e "  ${YELLOW}Changed:${RESET} $rel_path"
        fi
      else
        changed=$((changed + 1))
        echo -e "  ${GREEN}New:${RESET} $rel_path"
      fi
    fi
  done

  if [[ $changed -eq 0 ]]; then
    success "Everything is up to date."
    exit 0
  fi

  echo ""
  info "$changed file(s) have updates available."
  echo ""

  # Show diffs
  for rel_path in "${update_files[@]}"; do
    local tmp_file="$tmp_dir/$rel_path"
    if [[ -f "$tmp_file" && -f "$SCRIPT_DIR/$rel_path" ]]; then
      if ! diff -q "$SCRIPT_DIR/$rel_path" "$tmp_file" &>/dev/null; then
        echo -e "\n${BOLD}--- $rel_path ---${RESET}"
        diff --color=auto -u "$SCRIPT_DIR/$rel_path" "$tmp_file" || true
      fi
    fi
  done

  echo ""
  local apply="n"
  read -rp "Apply these updates? [y/N]: " apply
  if [[ "$apply" != "y" && "$apply" != "Y" ]]; then
    info "Update cancelled."
    exit 0
  fi

  # Apply updates
  for rel_path in "${update_files[@]}"; do
    local tmp_file="$tmp_dir/$rel_path"
    if [[ -f "$tmp_file" ]]; then
      if [[ ! -f "$SCRIPT_DIR/$rel_path" ]] || ! diff -q "$SCRIPT_DIR/$rel_path" "$tmp_file" &>/dev/null; then
        mkdir -p "$(dirname "$SCRIPT_DIR/$rel_path")"
        cp "$tmp_file" "$SCRIPT_DIR/$rel_path"
      fi
    fi
  done

  success "Updated $changed file(s)."
  info "Review changes with: git diff"
}

parse_flags() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h)
        show_help
        exit 0
        ;;
      --keep)
        KEEP_ARTIFACTS=true
        shift
        ;;
      --non-interactive)
        NON_INTERACTIVE=true
        shift
        ;;
      --update)
        run_update
        exit 0
        ;;
      *)
        error "Unknown flag: $1"
        echo "Run './scaffold --help' for usage."
        exit 1
        ;;
    esac
  done
}

show_help() {
  cat <<'HELP'
scaffold â€” Project initializer for Claude Code

Usage:
  ./scaffold [OPTIONS]

Options:
  --help, -h          Show this help message
  --keep              Don't remove scaffold artifacts after init
  --non-interactive   Use defaults for all prompts (for CI/automation)
  --update            Update skills, agents, and hooks from scaffold repo

What it does:
  1. Asks for project name, description, and language
  2. Configures Claude Code permissions based on your preferences
  3. Sets up language-specific tooling (linter, formatter, test runner)
  4. Optionally integrates Ralph Wiggum autonomous loop
  5. Helps you create or load a project plan
  6. Initializes git with a clean first commit
  7. Removes scaffold artifacts (unless --keep is used)

After running, your project is ready for Claude Code from session one.

Non-interactive defaults:
  Project name:    directory name
  Language:        python
  Permissions:     safe defaults only
  Ralph Wiggum:    disabled
  Project plan:    template only
HELP
}

# ---------------------------------------------------------------------------
# Step 1: Project basics
# ---------------------------------------------------------------------------
step_project_basics() {
  header "Project Setup"

  local dir_name
  dir_name="$(basename "$SCRIPT_DIR")"

  prompt PROJECT_NAME "Project name" "$dir_name"
  prompt PROJECT_DESC "Short description" "A project built with Claude Code"

  success "Project: $PROJECT_NAME"
}

# ---------------------------------------------------------------------------
# Step 2: Language selection
# ---------------------------------------------------------------------------
step_language() {
  header "Language Selection"

  info "Choose your primary language. This configures:"
  info "  - Language-specific conventions appended to CLAUDE.md"
  info "  - Linter, formatter, type checker, and test runner"
  info "  - Project config files (pyproject.toml, package.json, etc.)"
  echo ""

  prompt_choice LANGUAGE "Select primary language:" \
    "python    â€” pytest, ruff, mypy" \
    "typescript â€” vitest, eslint, tsc" \
    "go        â€” go test, golangci-lint" \
    "rust      â€” cargo test, clippy" \
    "none      â€” language-agnostic (configure later)"

  # Extract just the language name (before the spaces/dash)
  LANGUAGE="${LANGUAGE%% *}"

  if [[ "$LANGUAGE" == "none" ]]; then
    info "No language selected. You can add language support later by copying from templates/."
  else
    success "Language: $LANGUAGE"

    # Show recommendation
    echo ""
    case "$LANGUAGE" in
      python)
        info "${DIM}Recommendation: Use 'uv' or 'pip' with a virtual environment.${RESET}"
        info "${DIM}Run: python -m venv .venv && source .venv/bin/activate && pip install -e '.[dev]'${RESET}"
        ;;
      typescript)
        info "${DIM}Recommendation: Use Node.js 20+ with npm or pnpm.${RESET}"
        info "${DIM}Run: npm install${RESET}"
        ;;
      go)
        info "${DIM}Recommendation: Use Go 1.22+. Install golangci-lint for linting.${RESET}"
        info "${DIM}Run: go mod tidy${RESET}"
        info "${DIM}Note: Update go.mod module path to your full path (e.g., github.com/user/${PROJECT_NAME})${RESET}"
        ;;
      rust)
        info "${DIM}Recommendation: Use the latest stable Rust via rustup.${RESET}"
        info "${DIM}Run: cargo build${RESET}"
        ;;
    esac
  fi
}

# ---------------------------------------------------------------------------
# Step 3: Permissions
# ---------------------------------------------------------------------------
step_permissions() {
  header "Claude Code Permissions"

  info "Safe defaults are always auto-approved:"
  info "  File read/write, searches, git status/diff/log, make targets"
  echo ""
  info "The following need your preference:"
  echo ""

  prompt_yn ALLOW_COMMIT "Auto-approve git commit? (no = Claude asks each time)" true
  prompt_yn ALLOW_PUSH "Auto-approve git push? (no = Claude asks each time)" false
  prompt_yn ALLOW_PKG_MANAGER "Auto-approve package manager commands? (pip/npm/cargo/go)" false
  prompt_yn ALLOW_DOCKER "Auto-approve docker commands?" false

  success "Permissions configured"
}

# ---------------------------------------------------------------------------
# Step 4: Ralph Wiggum
# ---------------------------------------------------------------------------
step_ralph() {
  header "Ralph Wiggum (Autonomous Loop)"

  info "Ralph Wiggum runs Claude Code in iterative cycles:"
  info "  plan â†’ build â†’ test â†’ commit â†’ repeat"
  info "Each iteration gets a fresh context window."
  info "Progress persists via tasks/todo.md."
  echo ""

  prompt_yn ENABLE_RALPH "Enable Ralph Wiggum autonomous loop?" false

  if [[ "$ENABLE_RALPH" == true ]]; then
    success "Ralph Wiggum enabled"
  else
    info "Skipped. You can add Ralph later from templates/ralph/."
  fi
}

step_docker() {
  header "Docker (Optional)"

  prompt_yn ENABLE_DOCKER "Include Dockerfile and docker-compose.yml?" false

  if [[ "$ENABLE_DOCKER" == true ]]; then
    success "Docker enabled"
  else
    info "Skipped. You can add Docker later."
  fi
}

# ---------------------------------------------------------------------------
# Step 5: Project planning
# ---------------------------------------------------------------------------
step_planning() {
  header "Project Plan"

  info "A structured plan helps Claude Code understand your project from session one."
  echo ""

  prompt_choice PLAN_CHOICE "How would you like to set up your project plan?" \
    "Build one now   â€” answer a few questions to generate a plan" \
    "Load from file  â€” import an existing plan (markdown)" \
    "Skip            â€” use the blank template"

  PLAN_CHOICE="${PLAN_CHOICE%% *}"

  case "$PLAN_CHOICE" in
    Build)
      build_plan_interactive
      ;;
    Load)
      load_plan_from_file
      ;;
    Skip)
      info "Using blank template. Run '/plan' in Claude Code to create one later."
      local today
      today=$(date +%Y-%m-%d)
      cat > "$SCRIPT_DIR/tasks/todo.md" <<PLAN
# Task Plan â€” ${PROJECT_NAME}

> Created: ${today}
> Status: Not started

## Objective

_Define your project objective here, or run \`/plan\` in Claude Code._

## Plan

- [ ] 1. First task
- [ ] 2. Second task

## Decisions & Context

_Capture architectural decisions and tradeoffs here as you go._

## Results

_Filled in after completion._
PLAN
      ;;
  esac
}

build_plan_interactive() {
  echo ""
  info "Let's build your project plan."
  echo ""

  local objective components milestone risks

  prompt objective "What are you building? (one sentence)" ""
  prompt components "What are the major components or features? (comma-separated)" ""
  prompt milestone "What's the first milestone? (what should work first)" ""
  prompt risks "Any known risks or unknowns?" "None identified yet"

  # Generate structured plan
  local plan_file="$SCRIPT_DIR/tasks/todo.md"
  local today
  today=$(date +%Y-%m-%d)

  cat > "$plan_file" <<PLAN
# Task Plan â€” ${PROJECT_NAME}

> Updated: ${today}
> Branch: \`feat/initial-setup\`
> Status: ðŸŸ¡ Planning

---

## Objective

${objective}

## Plan

PLAN

  # Parse components into checkboxes
  local step=1
  IFS=',' read -ra COMP_ARRAY <<< "$components"
  for comp in "${COMP_ARRAY[@]}"; do
    comp="$(echo "$comp" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    if [[ -n "$comp" ]]; then
      echo "- [ ] ${step}. ${comp}" >> "$plan_file"
      step=$((step + 1))
    fi
  done

  cat >> "$plan_file" <<PLAN

### Checkpoints

- [ ] **Checkpoint 1**: ${milestone}

## Decisions & Context

_Capture architectural decisions and tradeoffs here as you go._

## Risks

- ${risks}

## Results

_Filled in after completion._
PLAN

  success "Plan written to tasks/todo.md"
}

load_plan_from_file() {
  echo ""
  local plan_path
  prompt plan_path "Path to your plan file" ""

  if [[ -z "$plan_path" ]]; then
    warn "No path provided. Using blank template."
    return
  fi

  # Expand ~ to home directory
  plan_path="${plan_path/#\~/$HOME}"

  if [[ ! -f "$plan_path" ]]; then
    warn "File not found: $plan_path. Using blank template."
    return
  fi

  cp "$plan_path" "$SCRIPT_DIR/tasks/todo.md"
  success "Plan loaded from $plan_path"
}

# ---------------------------------------------------------------------------
# Step 6: Git remote
# ---------------------------------------------------------------------------
step_git_remote() {
  header "Git Remote (Optional)"

  prompt GIT_REMOTE "Git remote URL (leave blank to skip)" ""

  if [[ -n "$GIT_REMOTE" ]]; then
    success "Remote: $GIT_REMOTE"
  fi
}

# ---------------------------------------------------------------------------
# Step 7: GitHub Project Management
# ---------------------------------------------------------------------------
step_github_pm() {
  header "GitHub Project Management"

  info "Issue templates and PR template are included in .github/"

  if [[ -z "$GIT_REMOTE" ]]; then
    info "No git remote set. Run 'make setup-github' when your remote is ready."
    return
  fi

  if ! command -v gh &>/dev/null; then
    info "GitHub CLI (gh) not found. Install it and run 'make setup-github' to set up labels."
    return
  fi

  if ! gh auth status &>/dev/null 2>&1; then
    info "GitHub CLI not authenticated. Run 'gh auth login' then 'make setup-github'."
    return
  fi

  prompt_yn SETUP_LABELS "Create issue labels (type, priority, status)?" true
  prompt_yn SETUP_KANBAN "Create a GitHub Projects kanban board?" false
}

extract_repo_from_remote() {
  local url="$GIT_REMOTE"
  # Handle SSH: git@github.com:user/repo.git
  if [[ "$url" == git@github.com:* ]]; then
    url="${url#git@github.com:}"
    url="${url%.git}"
    echo "$url"
    return
  fi
  # Handle HTTPS: https://github.com/user/repo.git
  if [[ "$url" == https://github.com/* ]]; then
    url="${url#https://github.com/}"
    url="${url%.git}"
    echo "$url"
    return
  fi
  echo ""
}

create_github_labels() {
  info "Creating issue labels..."
  local repo
  repo="$(extract_repo_from_remote)"
  if [[ -z "$repo" ]]; then
    warn "Could not determine GitHub repo from remote URL."
    return
  fi

  # Type labels
  gh label create "bug" --color "d73a4a" --description "Something isn't working" --repo "$repo" --force 2>/dev/null || true
  gh label create "feature" --color "0075ca" --description "New feature or enhancement" --repo "$repo" --force 2>/dev/null || true
  gh label create "task" --color "0e8a16" --description "Development task or chore" --repo "$repo" --force 2>/dev/null || true
  gh label create "chore" --color "e4e669" --description "Maintenance or cleanup" --repo "$repo" --force 2>/dev/null || true
  gh label create "refactor" --color "d4c5f9" --description "Code restructuring, no behavior change" --repo "$repo" --force 2>/dev/null || true

  # Priority labels
  gh label create "P0-critical" --color "b60205" --description "Drop everything" --repo "$repo" --force 2>/dev/null || true
  gh label create "P1-high" --color "d93f0b" --description "Fix this sprint" --repo "$repo" --force 2>/dev/null || true
  gh label create "P2-medium" --color "fbca04" --description "Plan for next sprint" --repo "$repo" --force 2>/dev/null || true
  gh label create "P3-low" --color "c5def5" --description "Nice to have" --repo "$repo" --force 2>/dev/null || true

  # Status labels
  gh label create "needs-triage" --color "f9d0c4" --description "Needs review and prioritization" --repo "$repo" --force 2>/dev/null || true
  gh label create "ready" --color "0e8a16" --description "Ready to be picked up" --repo "$repo" --force 2>/dev/null || true
  gh label create "blocked" --color "b60205" --description "Waiting on external dependency" --repo "$repo" --force 2>/dev/null || true
  gh label create "in-progress" --color "1d76db" --description "Currently being worked on" --repo "$repo" --force 2>/dev/null || true

  success "Labels created (type, priority, status)"
}

create_github_project() {
  info "Creating GitHub Projects kanban board..."
  local repo
  repo="$(extract_repo_from_remote)"
  local owner="${repo%%/*}"

  local project_url
  project_url="$(gh project create --title "${PROJECT_NAME}" --owner "$owner" 2>/dev/null)" || true

  if [[ -n "$project_url" ]]; then
    success "Kanban board created: $project_url"
  else
    warn "Could not create project board. Create one manually at https://github.com/${repo}/projects"
  fi
}

apply_github_pm() {
  if [[ "$SETUP_LABELS" != true && "$SETUP_KANBAN" != true ]]; then
    return
  fi

  header "Setting Up GitHub Project Management"

  # Push to remote first so labels can be created
  if [[ -n "$GIT_REMOTE" ]]; then
    info "Pushing to remote..."
    git -C "$SCRIPT_DIR" push -u origin main 2>/dev/null || true
  fi

  if ! command -v gh &>/dev/null || ! gh auth status &>/dev/null 2>&1; then
    info "GitHub CLI not available. Run 'make setup-github' to create labels and project board."
    return
  fi

  if [[ "$SETUP_LABELS" == true ]]; then
    create_github_labels
  fi

  if [[ "$SETUP_KANBAN" == true ]]; then
    create_github_project
  fi
}

# ---------------------------------------------------------------------------
# Apply: Template engine
# ---------------------------------------------------------------------------
apply_templates() {
  header "Applying Configuration"

  # --- Append language conventions to CLAUDE.md (before placeholder replacement) ---
  if [[ "$LANGUAGE" != "none" && -f "$SCRIPT_DIR/templates/$LANGUAGE/CONVENTIONS.md" ]]; then
    info "Appending $LANGUAGE conventions to CLAUDE.md..."
    echo "" >> "$SCRIPT_DIR/CLAUDE.md"
    echo "---" >> "$SCRIPT_DIR/CLAUDE.md"
    echo "" >> "$SCRIPT_DIR/CLAUDE.md"
    cat "$SCRIPT_DIR/templates/$LANGUAGE/CONVENTIONS.md" >> "$SCRIPT_DIR/CLAUDE.md"
    success "CLAUDE.md updated with $LANGUAGE conventions"
  fi

  # --- Replace placeholders in CLAUDE.md (after conventions are appended) ---
  info "Customizing CLAUDE.md..."
  local escaped_name escaped_desc
  escaped_name="$(sed_escape "$PROJECT_NAME")"
  escaped_desc="$(sed_escape "$PROJECT_DESC")"
  sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/CLAUDE.md"
  sed -i "s/{{PROJECT_DESCRIPTION}}/${escaped_desc}/g" "$SCRIPT_DIR/CLAUDE.md"

  # --- Place language-specific config files ---
  if [[ "$LANGUAGE" != "none" ]]; then
    info "Installing $LANGUAGE config files..."

    local tmpl_dir="$SCRIPT_DIR/templates/$LANGUAGE"

    # Process .tmpl files (replace placeholders, remove .tmpl extension)
    for tmpl in "$tmpl_dir"/*.tmpl; do
      if [[ -f "$tmpl" ]]; then
        local dest_name
        dest_name="$(basename "$tmpl" .tmpl)"
        sed "s/{{PROJECT_NAME}}/${escaped_name}/g; s/{{PROJECT_DESCRIPTION}}/${escaped_desc}/g" \
          "$tmpl" > "$SCRIPT_DIR/$dest_name"
        success "  Created $dest_name"
      fi
    done

    # Copy non-template config files (not CONVENTIONS.md, not .tmpl, not gitignore.append)
    for cfg in "$tmpl_dir"/*; do
      local basename
      basename="$(basename "$cfg")"
      if [[ "$basename" != "CONVENTIONS.md" && \
            "$basename" != "gitignore.append" && \
            "$basename" != *.tmpl && \
            -f "$cfg" ]]; then
        cp "$cfg" "$SCRIPT_DIR/$basename"
        success "  Created $basename"
      fi
    done

    # Append language-specific gitignore entries
    if [[ -f "$tmpl_dir/gitignore.append" ]]; then
      cat "$tmpl_dir/gitignore.append" >> "$SCRIPT_DIR/.gitignore"
      success "  Updated .gitignore with $LANGUAGE entries"
    fi

    # Create src directory
    case "$LANGUAGE" in
      python)
        local pkg_name="${PROJECT_NAME//-/_}"
        mkdir -p "$SCRIPT_DIR/src/$pkg_name"
        touch "$SCRIPT_DIR/src/$pkg_name/__init__.py"
        success "  Created src/$pkg_name/"
        ;;
      typescript)
        mkdir -p "$SCRIPT_DIR/src"
        cat > "$SCRIPT_DIR/src/index.ts" <<'TS'
export function main(): void {
  console.log("Hello from {{PROJECT_NAME}}");
}
TS
        sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/index.ts"
        success "  Created src/index.ts"
        ;;
      go)
        mkdir -p "$SCRIPT_DIR/cmd/$PROJECT_NAME"
        cat > "$SCRIPT_DIR/cmd/$PROJECT_NAME/main.go" <<'GO'
package main

import "fmt"

func main() {
	fmt.Println("Hello from {{PROJECT_NAME}}")
}
GO
        sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/cmd/$PROJECT_NAME/main.go"
        success "  Created cmd/$PROJECT_NAME/main.go"
        ;;
      rust)
        mkdir -p "$SCRIPT_DIR/src"
        cat > "$SCRIPT_DIR/src/main.rs" <<'RUST'
fn main() {
    println!("Hello from {{PROJECT_NAME}}");
}
RUST
        sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/main.rs"
        success "  Created src/main.rs"
        ;;
    esac
  fi

  # --- Configure permissions ---
  info "Configuring Claude Code permissions..."
  apply_permissions

  # --- Ralph Wiggum ---
  if [[ "$ENABLE_RALPH" == true ]]; then
    info "Setting up Ralph Wiggum..."
    mkdir -p "$SCRIPT_DIR/scripts"
    cp "$SCRIPT_DIR/templates/ralph/ralph-loop.sh" "$SCRIPT_DIR/scripts/ralph-loop.sh"
    chmod +x "$SCRIPT_DIR/scripts/ralph-loop.sh"
    cp "$SCRIPT_DIR/templates/ralph/PROMPT_build.md" "$SCRIPT_DIR/PROMPT_build.md"
    cp "$SCRIPT_DIR/templates/ralph/PROMPT_plan.md" "$SCRIPT_DIR/PROMPT_plan.md"
    success "Ralph Wiggum installed (scripts/ralph-loop.sh)"
  fi

  # --- Generate project README (replaces scaffold README) ---
  info "Generating project README..."
  local getting_started=""
  case "$LANGUAGE" in
    python)
      getting_started="# Set up virtual environment
python -m venv .venv
source .venv/bin/activate
pip install -e '.[dev]'" ;;
    typescript)
      getting_started="# Install dependencies
npm install" ;;
    go)
      getting_started="# Install dependencies
go mod tidy" ;;
    rust)
      getting_started="# Build
cargo build" ;;
    *)
      getting_started="# Install dependencies (configure for your language)" ;;
  esac

  cat > "$SCRIPT_DIR/README.md" <<README
# ${PROJECT_NAME}

${PROJECT_DESC}

## Getting Started

\`\`\`bash
${getting_started}

# Run tests
make test
\`\`\`

## Development

| Command | Description |
|---------|-------------|
| \`make test\` | Run all test tiers |
| \`make lint\` | Run linter |
| \`make fmt\` | Auto-format code |
| \`make typecheck\` | Run type checker |
| \`make build\` | Compile/build |
| \`make check\` | lint + typecheck + test (pre-PR gate) |

### Claude Code

This project is configured for [Claude Code](https://docs.anthropic.com/en/docs/claude-code) with:

- Agent constitution (\`CLAUDE.md\`)
- 13 slash commands: \`/start\`, \`/plan\`, \`/review\`, \`/test\`, \`/backlog\`, \`/doctor\`, \`/lesson\`, \`/checkpoint\`, \`/status\`, \`/simplify\`, \`/index\`, \`/save\`, \`/load\`
- 8 agent specifications in \`agents/\`
- Task management in \`tasks/\`

## License

[MIT](LICENSE)
README
  success "README.md generated for ${PROJECT_NAME}"

  # --- Generate GETTING_STARTED.md (first-session onboarding guide) ---
  info "Generating getting started guide..."
  local env_setup=""
  case "$LANGUAGE" in
    python)
      env_setup="### Set Up Your Environment

\`\`\`bash
python -m venv .venv
source .venv/bin/activate
pip install -e '.[dev]'
\`\`\`" ;;
    typescript)
      env_setup="### Set Up Your Environment

\`\`\`bash
npm install
\`\`\`" ;;
    go)
      env_setup="### Set Up Your Environment

\`\`\`bash
go mod tidy
\`\`\`" ;;
    rust)
      env_setup="### Set Up Your Environment

\`\`\`bash
cargo build
\`\`\`" ;;
    *)
      env_setup="### Set Up Your Environment

Install dependencies for your chosen language, then come back here." ;;
  esac

  cat > "$SCRIPT_DIR/GETTING_STARTED.md" <<GUIDE
# Getting Started with ${PROJECT_NAME}

Welcome! This guide walks you through your first 10 minutes with Claude Code.

## Step 1: Set Up

${env_setup}

## Step 2: Launch Claude Code

\`\`\`bash
claude
\`\`\`

## Step 3: Start Building

The easiest way to get going is to type:

\`\`\`
/start
\`\`\`

This will walk you through creating your first plan and (optionally) your first GitHub issue.

**Or, if you already know what you want to build**, just tell Claude:

\`\`\`
I want to build [your idea here]. Help me create a plan.
\`\`\`

Claude will create a structured plan in \`tasks/todo.md\` and ask for your approval before writing any code.

## Step 4: Build

Once your plan is approved, tell Claude to start:

\`\`\`
Let's start on step 1.
\`\`\`

Claude will work through the plan step by step, committing as it goes. You stay in control â€” it will check in at each step.

## Your Toolkit

Here are the commands you'll use most:

| Command | What It Does | When to Use It |
|---------|-------------|----------------|
| \`/start\` | Guided first-session setup | Right now (first time only) |
| \`/plan\` | Create or refine a project plan | Starting a new feature or task |
| \`/status\` | See progress and what's next | Any time you lose track |
| \`/backlog show\` | See open GitHub issues by priority | Picking what to work on |
| \`/backlog pick #N\` | Start working on issue #N | Beginning a task |
| \`/checkpoint\` | Commit progress and update plan | After completing a step |
| \`/test\` | Run tests and analyze results | Before committing |
| \`/save\` | Save session state for later | Ending a session |
| \`/load\` | Restore previous session context | Starting a new session |
| \`/lesson\` | Record what you learned | After fixing a tricky bug |

## How It Works

Your project has a few key files that Claude reads automatically:

- **\`CLAUDE.md\`** â€” The "rules" for how Claude works in your project (commit conventions, testing requirements, safety guardrails)
- **\`tasks/todo.md\`** â€” Your current plan and progress
- **\`tasks/lessons.md\`** â€” Things Claude learned from past sessions (mistakes to avoid, patterns that work)

You don't need to read these files â€” Claude uses them behind the scenes. But feel free to peek if you're curious.

## Tips

- **Be specific.** "Build a REST API for managing todos with CRUD endpoints" works better than "build something."
- **Let Claude plan first.** It will create a step-by-step plan before writing code. Review and approve it.
- **Commit often.** Use \`/checkpoint\` after each working piece. Small commits are easier to review and revert.
- **Ask questions.** Claude will ask you when it needs clarification. You can also ask it anything about the code.
GUIDE
  success "GETTING_STARTED.md generated"

  # --- Generate CI workflow ---
  info "Generating CI workflow..."
  mkdir -p "$SCRIPT_DIR/.github/workflows"

  local ci_setup=""
  local ci_lang_name=""
  case "$LANGUAGE" in
    python)
      ci_lang_name="Python"
      ci_setup="
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m venv .venv
          source .venv/bin/activate
          pip install -e '.[dev]'" ;;
    typescript)
      ci_lang_name="TypeScript"
      ci_setup="
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci" ;;
    go)
      ci_lang_name="Go"
      ci_setup="
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'" ;;
    rust)
      ci_lang_name="Rust"
      ci_setup="
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt" ;;
    *)
      ci_lang_name="Generic"
      ci_setup="" ;;
  esac

  cat > "$SCRIPT_DIR/.github/workflows/ci.yml" <<CIEOF
name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  check:
    name: Lint, typecheck, and test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
${ci_setup}

      - name: Run checks
        run: make check
CIEOF
  success "CI workflow generated (.github/workflows/ci.yml)"

  # --- Generate .env.example ---
  info "Generating .env.example..."
  cat > "$SCRIPT_DIR/.env.example" <<'ENVEOF'
# Environment variables for this project
# Copy to .env and fill in values: cp .env.example .env
# NEVER commit .env â€” it's in .gitignore

# Example:
# DATABASE_URL=postgresql://localhost:5432/mydb
# API_KEY=your-api-key-here
ENVEOF
  success ".env.example generated"

  # --- Generate CHANGELOG.md ---
  info "Generating CHANGELOG.md..."
  cat > "$SCRIPT_DIR/CHANGELOG.md" <<CHLOG
# Changelog

All notable changes to ${PROJECT_NAME} will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/),
and this project adheres to [Semantic Versioning](https://semver.org/).

## [Unreleased]

### Added
- Initial project setup with scaffold framework
CHLOG
  success "CHANGELOG.md generated"

  # --- Generate pre-commit config ---
  info "Generating pre-commit config..."
  local precommit_hooks=""
  case "$LANGUAGE" in
    python)
      precommit_hooks="  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.4.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format" ;;
    typescript)
      precommit_hooks="  - repo: local
    hooks:
      - id: eslint
        name: eslint
        entry: npx eslint --fix
        language: system
        types: [ts, tsx, js, jsx]" ;;
    go)
      precommit_hooks="  - repo: https://github.com/golangci/golangci-lint
    rev: v1.59.0
    hooks:
      - id: golangci-lint" ;;
    rust)
      precommit_hooks="  - repo: local
    hooks:
      - id: cargo-fmt
        name: cargo fmt
        entry: cargo fmt --
        language: system
        types: [rust]
      - id: cargo-clippy
        name: cargo clippy
        entry: cargo clippy -- -D warnings
        language: system
        types: [rust]
        pass_filenames: false" ;;
    *)
      precommit_hooks="" ;;
  esac

  cat > "$SCRIPT_DIR/.pre-commit-config.yaml" <<PCEOF
# Pre-commit hooks â€” run automatically before each commit
# Install: pip install pre-commit && pre-commit install
# Manual run: pre-commit run --all-files
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
        args: ['--maxkb=500']
      - id: detect-private-key
      - id: check-merge-conflict
${precommit_hooks}
  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.5.0
    hooks:
      - id: detect-secrets
        args: ['--baseline', '.secrets.baseline']
PCEOF
  success "Pre-commit config generated (.pre-commit-config.yaml)"

  # --- Generate Docker files (if enabled) ---
  if [[ "$ENABLE_DOCKER" == true ]]; then
    info "Generating Docker files..."

    case "$LANGUAGE" in
      python)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM python:3.12-slim AS base

WORKDIR /app

COPY pyproject.toml ./
RUN pip install --no-cache-dir .

COPY src/ ./src/

EXPOSE 8000
CMD ["python", "-m", "uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
DKEOF
        ;;
      typescript)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./

EXPOSE 3000
CMD ["node", "dist/index.js"]
DKEOF
        ;;
      go)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM golang:1.22-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 go build -o /bin/app ./cmd/

FROM alpine:3.19
RUN apk add --no-cache ca-certificates
COPY --from=builder /bin/app /bin/app

EXPOSE 8080
CMD ["/bin/app"]
DKEOF
        ;;
      rust)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM rust:1.78-slim AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs && cargo build --release && rm -rf src
COPY src/ ./src/
RUN touch src/main.rs && cargo build --release

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y --no-install-recommends ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/app /usr/local/bin/app

EXPOSE 8080
CMD ["app"]
DKEOF
        ;;
      *)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM ubuntu:22.04

WORKDIR /app
COPY . .

# Configure for your language
# RUN apt-get update && apt-get install -y ...

EXPOSE 8080
CMD ["echo", "Configure this Dockerfile for your project"]
DKEOF
        ;;
    esac

    cat > "$SCRIPT_DIR/docker-compose.yml" <<DCEOF
services:
  app:
    build: .
    ports:
      - "8080:8080"
    env_file:
      - .env
    volumes:
      - .:/app
    # Uncomment for development with hot reload:
    # command: ["your-dev-command-here"]

  # Add services as needed:
  # db:
  #   image: postgres:16-alpine
  #   environment:
  #     POSTGRES_DB: ${PROJECT_NAME}
  #     POSTGRES_USER: postgres
  #     POSTGRES_PASSWORD: postgres
  #   ports:
  #     - "5432:5432"
  #   volumes:
  #     - db_data:/var/lib/postgresql/data

# volumes:
#   db_data:
DCEOF
    success "Docker files generated (Dockerfile, docker-compose.yml)"
  fi

  # --- Generate release workflow ---
  info "Generating release workflow..."
  cat > "$SCRIPT_DIR/.github/workflows/release.yml" <<'RLEOF'
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract changelog for this version
        id: changelog
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          # Extract section for this version from CHANGELOG.md
          NOTES=$(awk "/^## \[${VERSION}\]/{flag=1; next} /^## \[/{flag=0} flag" CHANGELOG.md)
          if [ -z "$NOTES" ]; then
            NOTES="Release ${GITHUB_REF_NAME}"
          fi
          {
            echo 'notes<<EOF'
            echo "$NOTES"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          TAG_NAME: ${{ github.ref_name }}
          RELEASE_NOTES: ${{ steps.changelog.outputs.notes }}
        run: |
          gh release create "$TAG_NAME" \
            --title "$TAG_NAME" \
            --notes "$RELEASE_NOTES"
RLEOF
  success "Release workflow generated (.github/workflows/release.yml)"
}

apply_permissions() {
  local settings="$SCRIPT_DIR/.claude/settings.json"
  local tmp_settings
  tmp_settings=$(mktemp)

  # Start with existing settings and add user-chosen permissions
  cp "$settings" "$tmp_settings"

  # Build the additional allow rules
  local additions=""

  if [[ "$ALLOW_COMMIT" == true ]]; then
    additions="$additions\"Bash(git commit *)\", \"Bash(git commit -m *)\", "
  fi

  if [[ "$ALLOW_PUSH" == true ]]; then
    additions="$additions\"Bash(git push *)\", \"Bash(git push)\", "
  fi

  if [[ "$ALLOW_PKG_MANAGER" == true ]]; then
    case "$LANGUAGE" in
      python)    additions="$additions\"Bash(pip install *)\", \"Bash(pip install)\", \"Bash(uv *)\", " ;;
      typescript) additions="$additions\"Bash(npm install *)\", \"Bash(npm install)\", \"Bash(npm ci)\", \"Bash(npx *)\", " ;;
      go)        additions="$additions\"Bash(go get *)\", \"Bash(go mod *)\", " ;;
      rust)      additions="$additions\"Bash(cargo build *)\", \"Bash(cargo add *)\", " ;;
      none)      additions="$additions\"Bash(pip install *)\", \"Bash(npm install *)\", \"Bash(go get *)\", \"Bash(cargo add *)\", " ;;
    esac
  fi

  if [[ "$ALLOW_DOCKER" == true ]]; then
    additions="$additions\"Bash(docker build *)\", \"Bash(docker compose *)\", \"Bash(docker run *)\", "
  fi

  # If we have additions, insert them into the allow array
  if [[ -n "$additions" ]]; then
    # Remove trailing comma+space
    additions="${additions%, }"
    # Insert after the last existing allow entry (before the closing bracket)
    # Use python/sed to safely modify JSON... but we're zero-dependency bash.
    # Simple approach: replace the last entry in allow array with itself + new entries
    local last_allow
    last_allow=$(grep -n '"Bash(mkdir \*)' "$tmp_settings" | tail -1 | cut -d: -f1)
    if [[ -n "$last_allow" ]]; then
      sed -i "${last_allow}s|\"Bash(mkdir \*)\"|\"Bash(mkdir *)\",\n      ${additions}|" "$tmp_settings"
    fi
  fi

  cp "$tmp_settings" "$settings"
  rm -f "$tmp_settings"
  success "  Permissions updated in .claude/settings.json"
}

# ---------------------------------------------------------------------------
# Cleanup: Remove scaffold artifacts
# ---------------------------------------------------------------------------
cleanup_artifacts() {
  if [[ "$KEEP_ARTIFACTS" == true ]]; then
    info "Keeping scaffold artifacts (--keep flag)."
    return
  fi

  header "Cleaning Up"

  info "Removing scaffold artifacts..."
  rm -rf "$SCRIPT_DIR/templates"
  success "  Removed templates/"

  # Remove this script last
  local self="$SCRIPT_DIR/scaffold"
  if [[ -f "$self" ]]; then
    rm "$self"
    success "  Removed scaffold"
  fi

  success "Project is clean â€” no scaffold artifacts remain."
}

# ---------------------------------------------------------------------------
# Git initialization
# ---------------------------------------------------------------------------
init_git() {
  header "Git Initialization"

  # If cloned from scaffold repo, remove the cloned .git to start fresh
  if [[ -d "$SCRIPT_DIR/.git" ]]; then
    local remote_url
    remote_url="$(git -C "$SCRIPT_DIR" remote get-url origin 2>/dev/null || echo "")"
    if [[ "$remote_url" == *"sakebomb/scaffold"* ]]; then
      info "Removing cloned scaffold git history..."
      rm -rf "$SCRIPT_DIR/.git"
    fi
  fi

  # Initialize or verify git repo
  if [[ -d "$SCRIPT_DIR/.git" ]]; then
    info "Git repo already exists."
  else
    info "Initializing git repository..."
    git -C "$SCRIPT_DIR" init -b main
    success "Git repo initialized (main branch)"
  fi

  # Add remote if provided
  if [[ -n "$GIT_REMOTE" ]]; then
    git -C "$SCRIPT_DIR" remote add origin "$GIT_REMOTE" 2>/dev/null || \
      git -C "$SCRIPT_DIR" remote set-url origin "$GIT_REMOTE"
    success "Remote set: $GIT_REMOTE"
  fi

  # Stage and commit
  info "Creating initial commit..."
  git -C "$SCRIPT_DIR" add -A
  git -C "$SCRIPT_DIR" commit -m "$(cat <<'EOF'
feat: initialize project with scaffold framework

- CLAUDE.md agent constitution with project conventions
- .claude/ settings, skills (slash commands), and hooks
- Tiered test structure (unit/integration/agent)
- Task management (todo, lessons, tests)
- Agent specifications
- Language-aware Makefile

Scaffolded with https://github.com/sakebomb/scaffold
EOF
  )"
  success "Initial commit created"

  # Show status
  echo ""
  info "Branch: $(git -C "$SCRIPT_DIR" rev-parse --abbrev-ref HEAD)"
  info "Commits: $(git -C "$SCRIPT_DIR" rev-list --count HEAD)"
}

# ---------------------------------------------------------------------------
# Summary
# ---------------------------------------------------------------------------
show_summary() {
  header "Setup Complete"

  echo -e "${GREEN}Your project '${PROJECT_NAME}' is ready for Claude Code.${RESET}"
  echo ""
  echo "What's configured:"
  echo -e "  ${BOLD}CLAUDE.md${RESET}           Agent constitution + conventions"
  echo -e "  ${BOLD}.claude/settings${RESET}    Tiered permissions"
  echo -e "  ${BOLD}.claude/skills/${RESET}     13 slash commands (/start, /plan, /backlog, /save, /load, ...)"
  echo -e "  ${BOLD}.claude/hooks/${RESET}      Main branch protection"
  echo -e "  ${BOLD}.github/${RESET}            Issue templates, PR template, CI workflow"
  echo -e "  ${BOLD}agents/${RESET}             8 agent specifications"
  echo -e "  ${BOLD}tasks/${RESET}              Plan, lessons, test registry"
  echo -e "  ${BOLD}Makefile${RESET}            test, lint, fmt, typecheck, build, check, setup-github"
  echo -e "  ${BOLD}.pre-commit${RESET}         Linting + secret scanning on commit"

  if [[ "$LANGUAGE" != "none" ]]; then
    echo -e "  ${BOLD}Language${RESET}            $LANGUAGE (conventions, configs, tooling)"
  fi

  if [[ "$ENABLE_DOCKER" == true ]]; then
    echo -e "  ${BOLD}Docker${RESET}              Dockerfile + docker-compose.yml"
  fi

  if [[ "$ENABLE_RALPH" == true ]]; then
    echo -e "  ${BOLD}Ralph Wiggum${RESET}       scripts/ralph-loop.sh (autonomous loop)"
  fi

  echo ""
  echo "Next steps:"
  echo "  1. cd $(basename "$SCRIPT_DIR")"
  echo "  2. Start Claude Code: claude"
  echo "  3. Type: /start"
  echo ""
  echo -e "  ${DIM}Or skip /start and just tell Claude what to build:${RESET}"
  echo "  \"I want to build [your idea]. Help me create a plan.\""

  if [[ "$ENABLE_RALPH" == true ]]; then
    echo ""
    echo "  Ralph Wiggum (autonomous loop):"
    echo "  ./scripts/ralph-loop.sh plan   â€” autonomous planning"
    echo "  ./scripts/ralph-loop.sh build  â€” autonomous building"
  fi

  echo ""
  echo -e "  ${DIM}Full walkthrough: GETTING_STARTED.md${RESET}"
  echo ""
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------
main() {
  parse_flags "$@"

  echo ""
  echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
  echo -e "${BOLD}â•‘          Scaffold â€” Claude Code Setup            â•‘${RESET}"
  echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"

  step_project_basics
  step_language
  step_permissions
  step_ralph
  step_docker
  step_planning
  step_git_remote
  step_github_pm

  apply_templates
  cleanup_artifacts
  init_git
  apply_github_pm
  show_summary
}

main "$@"
