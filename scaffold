#!/usr/bin/env bash
# =============================================================================
# scaffold â€” Project initializer for Claude Code
# =============================================================================
# Sets up a project optimized for Claude Code with:
#   - CLAUDE.md agent constitution + language-specific conventions
#   - .claude/ settings, skills (slash commands), and hooks
#   - Tiered test structure + Makefile
#   - Task management (todo, lessons, tests)
#   - Agent specifications
#   - Optional Ralph Wiggum autonomous loop
#
# Usage:
#   ./scaffold                  Interactive setup
#   ./scaffold --help           Show help
#   ./scaffold --keep           Don't remove scaffold artifacts after init
#   ./scaffold --non-interactive Use defaults for all prompts
#   ./scaffold --dry-run        Preview what would be created
#   ./scaffold --completions    Output bash completion script
#   ./scaffold --version        Print scaffold version
#   ./scaffold --migrate        Add scaffold to an existing project
#   ./scaffold --add <lang>     Layer a second language into existing project
# =============================================================================
set -eEuo pipefail

# ---------------------------------------------------------------------------
# Globals
# ---------------------------------------------------------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$PWD"

# Template resolution: local repo â†’ installed location
if [[ -d "$SCRIPT_DIR/templates" ]]; then
  TEMPLATE_DIR="$SCRIPT_DIR/templates"
elif [[ -d "${SCAFFOLD_HOME:-$HOME/.scaffold}/templates" ]]; then
  TEMPLATE_DIR="${SCAFFOLD_HOME:-$HOME/.scaffold}/templates"
else
  TEMPLATE_DIR="$SCRIPT_DIR/templates"  # fallback (may not exist)
fi

SAVE_DEFAULTS=false
KEEP_ARTIFACTS=false
NON_INTERACTIVE=false
DRY_RUN=false
PROJECT_NAME=""
PROJECT_DESC=""
LANGUAGE=""
ENABLE_RALPH=false
GIT_REMOTE=""
ALLOW_COMMIT=false
ALLOW_PUSH=false
ALLOW_PKG_MANAGER=false
ALLOW_DOCKER=false
SETUP_LABELS=false
SETUP_KANBAN=false
ENABLE_DOCKER=false
ENABLE_VSCODE=false
ARCHETYPE="none"
ADD_LANGUAGE=""
ADD_DIR=""
ADD_MODE=false
VERIFY_MODE=false
MIGRATE_MODE=false
SCAFFOLD_VERSION="1.0.0"

# Rollback tracking
PRE_SNAPSHOT=""

# Colors (disabled if not a terminal)
if [[ -t 1 ]]; then
  BOLD='\033[1m'
  DIM='\033[2m'
  GREEN='\033[0;32m'
  YELLOW='\033[0;33m'
  CYAN='\033[0;36m'
  RED='\033[0;31m'
  RESET='\033[0m'
else
  BOLD='' DIM='' GREEN='' YELLOW='' CYAN='' RED='' RESET=''
fi

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
info()    { echo -e "${CYAN}â–¸${RESET} $*"; }
success() { echo -e "${GREEN}âœ“${RESET} $*"; }
warn()    { echo -e "${YELLOW}âš ${RESET} $*"; }
error()   { echo -e "${RED}âœ—${RESET} $*" >&2; }
header()  { echo -e "\n${BOLD}â•â•â• $* â•â•â•${RESET}\n"; }

# Snapshot all files that exist before scaffold modifies anything
snapshot_pre_existing() {
  PRE_SNAPSHOT="$(mktemp)"
  find "$PROJECT_DIR" -not -path "$PROJECT_DIR/.git/*" -not -name '.git' | sort > "$PRE_SNAPSHOT"
}

# Rollback handler â€” called on ERR if trap is set
rollback_on_failure() {
  local exit_code=$?
  echo ""
  error "Scaffold failed (exit code: $exit_code)"
  echo ""

  # Find files created since snapshot
  local post_snapshot
  post_snapshot="$(mktemp)"
  find "$PROJECT_DIR" -not -path "$PROJECT_DIR/.git/*" -not -name '.git' | sort > "$post_snapshot"
  local new_files
  new_files="$(comm -13 "$PRE_SNAPSHOT" "$post_snapshot" || true)"
  rm -f "$post_snapshot"

  if [[ -z "$new_files" ]]; then
    warn "No new files were created before the failure."
    rm -f "$PRE_SNAPSHOT"
    exit "$exit_code"
  fi

  warn "The following files were created before the failure:"
  echo "$new_files" | while IFS= read -r f; do
    echo "  ${f#"$PROJECT_DIR"/}"
  done
  echo ""

  if [[ "$NON_INTERACTIVE" == true ]]; then
    warn "Non-interactive mode: cleaning up created files automatically."
    perform_rollback "$new_files"
    rm -f "$PRE_SNAPSHOT"
    exit "$exit_code"
  fi

  local answer="n"
  read -rp "Roll back created files? [y/N]: " answer
  if [[ "$(to_lower "$answer")" == "y" || "$(to_lower "$answer")" == "yes" ]]; then
    perform_rollback "$new_files"
  else
    warn "Partial files left in place. Review manually."
  fi
  rm -f "$PRE_SNAPSHOT"
  exit "$exit_code"
}

# Remove files created during the run, deepest first
perform_rollback() {
  local new_files="$1"
  local removed=0
  # Sort in reverse so deeper paths are removed first
  echo "$new_files" | sort -r | while IFS= read -r f; do
    if [[ -f "$f" ]]; then
      rm -f "$f"
      removed=$((removed + 1))
    elif [[ -d "$f" ]] && [[ -z "$(ls -A "$f" 2>/dev/null)" ]]; then
      rmdir "$f" 2>/dev/null || true
      removed=$((removed + 1))
    fi
  done
  success "Rolled back created files."
}

# Lowercase a string (bash 3.2 compatible â€” avoids ${var,,})
to_lower() {
  printf '%s' "$1" | tr '[:upper:]' '[:lower:]'
}

# Portable sed in-place edit (BSD sed requires -i '', GNU sed uses -i)
sed_inplace() {
  if sed --version >/dev/null 2>&1; then
    sed -i "$@"
  else
    sed -i '' "$@"
  fi
}

# Escape string for use as sed replacement (handles /, &, \, newlines)
sed_escape() {
  printf '%s' "$1" | sed -e 's/[\/&\\]/\\&/g'
}

# Replace {{PROJECT_NAME}} and {{PROJECT_DESCRIPTION}} placeholders in a file (in-place)
replace_placeholders() {
  local file="$1"
  local escaped_name escaped_desc
  escaped_name="$(sed_escape "$PROJECT_NAME")"
  escaped_desc="$(sed_escape "$PROJECT_DESC")"
  sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g; s/{{PROJECT_DESCRIPTION}}/${escaped_desc}/g" "$file"
}

prompt() {
  local var_name="$1" prompt_text="$2" default="$3"
  if [[ "$NON_INTERACTIVE" == true ]]; then
    printf -v "$var_name" '%s' "$default"
    return
  fi
  local display_default=""
  if [[ -n "$default" ]]; then
    display_default=" ${DIM}[$default]${RESET}"
  fi
  echo -ne "${CYAN}?${RESET} ${prompt_text}${display_default}: "
  local input
  read -r input
  if [[ -z "$input" ]]; then
    printf -v "$var_name" '%s' "$default"
  else
    printf -v "$var_name" '%s' "$input"
  fi
}

prompt_yn() {
  local var_name="$1" prompt_text="$2" default="$3"
  if [[ "$NON_INTERACTIVE" == true ]]; then
    # Keep value from .scaffoldrc if it was explicitly set
    if [[ "$_RC_KEYS" != *":${var_name}:"* ]]; then
      printf -v "$var_name" '%s' "$default"
    fi
    return
  fi
  local yn_hint="y/n"
  if [[ "$default" == true ]]; then yn_hint="Y/n"; fi
  if [[ "$default" == false ]]; then yn_hint="y/N"; fi
  echo -ne "${CYAN}?${RESET} ${prompt_text} ${DIM}[$yn_hint]${RESET}: "
  local input
  read -r input
  case "$(to_lower "$input")" in
    y|yes) printf -v "$var_name" '%s' "true" ;;
    n|no)  printf -v "$var_name" '%s' "false" ;;
    *)     printf -v "$var_name" '%s' "$default" ;;
  esac
}

prompt_choice() {
  local var_name="$1" prompt_text="$2"
  shift 2
  local options=("$@")

  if [[ "$NON_INTERACTIVE" == true ]]; then
    # Keep value from .scaffoldrc if it was explicitly set
    if [[ "$_RC_KEYS" != *":${var_name}:"* ]]; then
      printf -v "$var_name" '%s' "${options[0]}"
    fi
    return
  fi

  echo -e "${CYAN}?${RESET} ${prompt_text}"
  local i=1
  for opt in "${options[@]}"; do
    echo -e "  ${BOLD}$i)${RESET} $opt"
    i=$((i + 1))
  done
  echo -ne "${DIM}  Enter number [1]: ${RESET}"
  local input
  read -r input
  if [[ -z "$input" || "$input" -lt 1 || "$input" -gt ${#options[@]} ]] 2>/dev/null; then
    printf -v "$var_name" '%s' "${options[0]}"
  else
    printf -v "$var_name" '%s' "${options[$((input - 1))]}"
  fi
}

# ---------------------------------------------------------------------------
# Parse CLI flags
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
# Update mode â€” pull latest skills, agents, hooks from scaffold repo
# ---------------------------------------------------------------------------
SCAFFOLD_REPO="https://raw.githubusercontent.com/sakebomb/scaffold/main"

run_update() {
  header "Scaffold Update"

  # Show project's scaffold version if available
  if [[ -f "$PROJECT_DIR/.scaffold-version" ]]; then
    local proj_ver proj_date
    proj_ver="$(grep '^version=' "$PROJECT_DIR/.scaffold-version" 2>/dev/null | cut -d= -f2)"
    proj_date="$(grep '^date=' "$PROJECT_DIR/.scaffold-version" 2>/dev/null | cut -d= -f2)"
    info "Project scaffolded with: v${proj_ver:-unknown} (${proj_date:-unknown})"
    info "Current scaffold:        v$SCAFFOLD_VERSION"
  fi

  info "Checking for updates from scaffold repo..."
  echo ""

  if ! command -v curl &>/dev/null; then
    error "curl is required for updates. Install it and try again."
    exit 1
  fi

  # Directories to update
  local update_dirs=(".claude/skills" ".claude/hooks" "agents")
  local update_files=()
  local changed=0

  # Discover files to update
  for dir in "${update_dirs[@]}"; do
    if [[ ! -d "$PROJECT_DIR/$dir" ]]; then
      info "Skipping $dir (directory not found)"
      continue
    fi
    while IFS= read -r -d '' file; do
      local rel_path="${file#"$PROJECT_DIR"/}"
      update_files+=("$rel_path")
    done < <(find "$PROJECT_DIR/$dir" -type f \( -name "*.md" -o -name "*.sh" -o -name "*.json" \) -print0 2>/dev/null | sort -z)
  done

  # Check each file for changes
  local tmp_dir
  tmp_dir="$(mktemp -d)"
  trap 'rm -rf "$tmp_dir"' EXIT

  for rel_path in "${update_files[@]}"; do
    local url="$SCAFFOLD_REPO/$rel_path"
    local tmp_file="$tmp_dir/$rel_path"
    mkdir -p "$(dirname "$tmp_file")"

    if curl -sf "$url" -o "$tmp_file" 2>/dev/null; then
      if [[ -f "$PROJECT_DIR/$rel_path" ]]; then
        if ! diff -q "$PROJECT_DIR/$rel_path" "$tmp_file" &>/dev/null; then
          changed=$((changed + 1))
          echo -e "  ${YELLOW}Changed:${RESET} $rel_path"
        fi
      else
        changed=$((changed + 1))
        echo -e "  ${GREEN}New:${RESET} $rel_path"
      fi
    fi
  done

  if [[ $changed -eq 0 ]]; then
    success "Everything is up to date."
    exit 0
  fi

  echo ""
  info "$changed file(s) have updates available."
  echo ""

  # Show diffs
  for rel_path in "${update_files[@]}"; do
    local tmp_file="$tmp_dir/$rel_path"
    if [[ -f "$tmp_file" && -f "$PROJECT_DIR/$rel_path" ]]; then
      if ! diff -q "$PROJECT_DIR/$rel_path" "$tmp_file" &>/dev/null; then
        echo -e "\n${BOLD}--- $rel_path ---${RESET}"
        diff --color=auto -u "$PROJECT_DIR/$rel_path" "$tmp_file" || true
      fi
    fi
  done

  echo ""
  local apply="n"
  read -rp "Apply these updates? [y/N]: " apply
  if [[ "$apply" != "y" && "$apply" != "Y" ]]; then
    info "Update cancelled."
    exit 0
  fi

  # Apply updates
  for rel_path in "${update_files[@]}"; do
    local tmp_file="$tmp_dir/$rel_path"
    if [[ -f "$tmp_file" ]]; then
      if [[ ! -f "$PROJECT_DIR/$rel_path" ]] || ! diff -q "$PROJECT_DIR/$rel_path" "$tmp_file" &>/dev/null; then
        mkdir -p "$(dirname "$PROJECT_DIR/$rel_path")"
        cp "$tmp_file" "$PROJECT_DIR/$rel_path"
      fi
    fi
  done

  success "Updated $changed file(s)."
  info "Review changes with: git diff"
}

# ---------------------------------------------------------------------------
# Shell completions
# ---------------------------------------------------------------------------
print_completions() {
  cat <<'COMP'
# Bash completion for scaffold
# Enable: source <(./scaffold --completions)
# Persist: ./scaffold --completions >> ~/.bashrc

_scaffold_completions() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local prev="${COMP_WORDS[COMP_CWORD-1]}"

  # Complete language after --add
  if [[ "$prev" == "--add" ]]; then
    COMPREPLY=($(compgen -W "python typescript go rust" -- "$cur"))
    return
  fi

  # Complete shell after --completions
  if [[ "$prev" == "--completions" ]]; then
    COMPREPLY=($(compgen -W "bash zsh" -- "$cur"))
    return
  fi

  # Complete flags
  local flags="--help --keep --non-interactive --dry-run --update --completions --version --migrate --add --dir --save-defaults --verify --install-template --list-templates"
  COMPREPLY=($(compgen -W "$flags" -- "$cur"))
}

complete -F _scaffold_completions ./scaffold
complete -F _scaffold_completions scaffold
COMP
}

print_zsh_completions() {
  cat <<'ZCOMP'
#compdef scaffold

# Zsh completion for scaffold
# Enable: source <(scaffold --completions zsh)
# Persist: scaffold --completions zsh >> ~/.zshrc

_scaffold() {
  local -a flags languages shells
  flags=(
    '--help[Show help message]'
    '--keep[Keep scaffold artifacts after init]'
    '--non-interactive[Use defaults for all prompts]'
    '--dry-run[Preview without writing anything]'
    '--update[Update skills, agents, and hooks]'
    '--completions[Output completion script]:shell:(bash zsh)'
    '--version[Print scaffold version]'
    '--migrate[Add scaffold to an existing project]'
    '--add[Layer a second language]:language:(python typescript go rust)'
    '--dir[Place language files in subdirectory]:directory:_directories'
    '--save-defaults[Save choices to ~/.scaffoldrc]'
    '--verify[Validate a scaffolded project]'
    '--install-template[Install a community template]:source:_files'
    '--list-templates[List available language templates]'
  )
  _arguments -s $flags
}

_scaffold "$@"
ZCOMP
}

# ---------------------------------------------------------------------------
# .scaffoldrc â€” persistent user defaults
# ---------------------------------------------------------------------------
# Track which variables were set by .scaffoldrc
_RC_KEYS=""

load_scaffoldrc() {
  local rc_file="${SCAFFOLDRC:-$HOME/.scaffoldrc}"
  [[ -f "$rc_file" ]] || return 0

  local key value
  while IFS='=' read -r key value; do
    # Skip comments and blank lines
    [[ -z "$key" || "$key" =~ ^[[:space:]]*# ]] && continue
    # Trim whitespace
    key="$(echo "$key" | xargs)"
    value="$(echo "$value" | xargs)"
    case "$key" in
      LANGUAGE)           LANGUAGE="$value"; _RC_KEYS="${_RC_KEYS}:LANGUAGE:" ;;
      ARCHETYPE)          ARCHETYPE="$value"; _RC_KEYS="${_RC_KEYS}:ARCHETYPE:" ;;
      ENABLE_DOCKER)      ENABLE_DOCKER="$value"; _RC_KEYS="${_RC_KEYS}:ENABLE_DOCKER:" ;;
      ENABLE_VSCODE)      ENABLE_VSCODE="$value"; _RC_KEYS="${_RC_KEYS}:ENABLE_VSCODE:" ;;
      ENABLE_RALPH)       ENABLE_RALPH="$value"; _RC_KEYS="${_RC_KEYS}:ENABLE_RALPH:" ;;
      ALLOW_COMMIT)       ALLOW_COMMIT="$value"; _RC_KEYS="${_RC_KEYS}:ALLOW_COMMIT:" ;;
      ALLOW_PUSH)         ALLOW_PUSH="$value"; _RC_KEYS="${_RC_KEYS}:ALLOW_PUSH:" ;;
      ALLOW_PKG_MANAGER)  ALLOW_PKG_MANAGER="$value"; _RC_KEYS="${_RC_KEYS}:ALLOW_PKG_MANAGER:" ;;
      ALLOW_DOCKER)       ALLOW_DOCKER="$value"; _RC_KEYS="${_RC_KEYS}:ALLOW_DOCKER:" ;;
      KEEP_ARTIFACTS)     KEEP_ARTIFACTS="$value"; _RC_KEYS="${_RC_KEYS}:KEEP_ARTIFACTS:" ;;
      *) ;; # ignore unknown keys
    esac
  done < "$rc_file"
}

save_scaffoldrc() {
  local rc_file="${SCAFFOLDRC:-$HOME/.scaffoldrc}"
  cat > "$rc_file" <<RCEOF
# ~/.scaffoldrc â€” scaffold defaults
# Generated by: scaffold --save-defaults
# These values are used as defaults. CLI flags override them.
LANGUAGE=$LANGUAGE
ARCHETYPE=$ARCHETYPE
ENABLE_DOCKER=$ENABLE_DOCKER
ENABLE_VSCODE=$ENABLE_VSCODE
ENABLE_RALPH=$ENABLE_RALPH
ALLOW_COMMIT=$ALLOW_COMMIT
ALLOW_PUSH=$ALLOW_PUSH
ALLOW_PKG_MANAGER=$ALLOW_PKG_MANAGER
ALLOW_DOCKER=$ALLOW_DOCKER
KEEP_ARTIFACTS=$KEEP_ARTIFACTS
RCEOF
  success "Defaults saved to $rc_file"
}

parse_flags() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h)
        show_help
        exit 0
        ;;
      --keep)
        KEEP_ARTIFACTS=true
        shift
        ;;
      --non-interactive)
        NON_INTERACTIVE=true
        shift
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --update)
        run_update
        exit 0
        ;;
      --completions)
        local shell_arg="${2:-}"
        if [[ "$shell_arg" == "bash" || "$shell_arg" == "zsh" ]]; then
          shift
        else
          # Auto-detect from $SHELL
          if [[ "${SHELL:-}" == */zsh ]]; then
            shell_arg="zsh"
          else
            shell_arg="bash"
          fi
        fi
        if [[ "$shell_arg" == "zsh" ]]; then
          print_zsh_completions
        else
          print_completions
        fi
        exit 0
        ;;
      --version)
        echo "scaffold $SCAFFOLD_VERSION"
        exit 0
        ;;
      --migrate)
        MIGRATE_MODE=true
        shift
        ;;
      --add)
        ADD_MODE=true
        if [[ -n "${2:-}" && ! "$2" =~ ^-- ]]; then
          local user_tpl="${SCAFFOLD_HOME:-$HOME/.scaffold}/templates"
          if [[ -d "$TEMPLATE_DIR/$2" || -d "$user_tpl/$2" ]]; then
            ADD_LANGUAGE="$2"
          else
            error "Unsupported language: $2"
            info "Run --list-templates to see available languages"
            exit 1
          fi
          shift 2
        else
          shift
        fi
        ;;
      --dir)
        if [[ -z "${2:-}" ]]; then
          error "--dir requires a path argument"
          exit 1
        fi
        ADD_DIR="$2"
        shift 2
        ;;
      --verify)
        VERIFY_MODE=true
        shift
        ;;
      --install-template)
        if [[ -z "${2:-}" ]]; then
          error "--install-template requires a URL or path argument"
          exit 1
        fi
        install_template "$2"
        exit $?
        ;;
      --list-templates)
        list_templates
        exit 0
        ;;
      --save-defaults)
        SAVE_DEFAULTS=true
        shift
        ;;
      *)
        error "Unknown flag: $1"
        echo "Run './scaffold --help' for usage."
        exit 1
        ;;
    esac
  done

  # --dir is only valid with --add
  if [[ -n "$ADD_DIR" && "$ADD_MODE" != true ]]; then
    error "--dir can only be used with --add"
    exit 1
  fi
}

show_help() {
  cat <<'HELP'
scaffold â€” Project initializer for Claude Code

Usage:
  ./scaffold [OPTIONS]

Options:
  --help, -h          Show this help message
  --keep              Don't remove scaffold artifacts after init
  --non-interactive   Use defaults for all prompts (for CI/automation)
  --dry-run           Preview what would be created without writing anything
  --update            Update skills, agents, and hooks from scaffold repo
  --completions [sh]  Output completion script (bash or zsh, auto-detects)
  --version           Print scaffold version
  --migrate           Add scaffold to an existing project (auto-detects language)
  --add [lang]        Layer a second language into an existing project
                      Supported: python, typescript, go, rust
                      Omit language for interactive selection
  --dir <path>        With --add: place language files in subdirectory (monorepo)
  --verify            Validate a scaffolded project (check files, placeholders, JSON)
  --install-template <url>  Install a community language template
  --list-templates    List built-in and installed language templates
  --save-defaults     Save current choices to ~/.scaffoldrc for future runs

What it does:
  1. Asks for project name, description, language, and archetype
  2. Configures Claude Code permissions based on your preferences
  3. Sets up language-specific tooling (linter, formatter, test runner)
  4. Generates archetype structure (CLI, API, or library starter files)
  5. Optionally integrates Ralph Wiggum autonomous loop
  6. Helps you create or load a project plan
  7. Initializes git with a clean first commit
  8. Removes scaffold artifacts (unless --keep is used)

After running, your project is ready for Claude Code from session one.

Non-interactive defaults:
  Project name:    directory name
  Language:        python
  Permissions:     safe defaults only
  Ralph Wiggum:    disabled
  Project plan:    template only
HELP
}

# ---------------------------------------------------------------------------
# Dry-run report â€” show what would be created without writing anything
# ---------------------------------------------------------------------------
dry_run_report() {
  echo ""
  header "Dry Run Preview"
  echo ""
  echo -e "  ${BOLD}Project:${RESET}     $PROJECT_NAME"
  echo -e "  ${BOLD}Description:${RESET} $PROJECT_DESC"
  echo -e "  ${BOLD}Language:${RESET}    $LANGUAGE"
  echo -e "  ${BOLD}Archetype:${RESET}  $ARCHETYPE"
  echo -e "  ${BOLD}Docker:${RESET}      $ENABLE_DOCKER"
  echo -e "  ${BOLD}VS Code:${RESET}    $ENABLE_VSCODE"
  echo -e "  ${BOLD}Ralph:${RESET}       $ENABLE_RALPH"
  echo ""
  echo -e "${BOLD}Files that would be created:${RESET}"
  echo ""

  # Common files (always created)
  echo "  CLAUDE.md"
  echo "  README.md"
  echo "  GETTING_STARTED.md"
  echo "  LICENSE"
  echo "  Makefile"
  echo "  .gitignore"
  echo "  .env.example"
  echo "  CHANGELOG.md"
  echo "  SECURITY.md"
  echo "  .pre-commit-config.yaml"
  echo "  .scaffold-version"
  echo "  .claude/settings.json"
  echo "  .claude/hooks/protect-main-branch.sh"

  # Skills
  local skills=(plan review test lesson checkpoint status simplify index save load backlog doctor start)
  for s in "${skills[@]}"; do
    echo "  .claude/skills/$s/SKILL.md"
  done

  # GitHub
  echo "  .github/ISSUE_TEMPLATE/bug.yml"
  echo "  .github/ISSUE_TEMPLATE/feature.yml"
  echo "  .github/ISSUE_TEMPLATE/task.yml"
  echo "  .github/ISSUE_TEMPLATE/config.yml"
  echo "  .github/pull_request_template.md"
  echo "  .github/workflows/ci.yml"
  echo "  .github/workflows/release.yml"

  # Agents
  local agents=(plan-agent research-agent code-review-agent test-runner-agent build-validator-agent code-architect-agent code-simplifier-agent verify-agent)
  echo "  agents/README.md"
  for a in "${agents[@]}"; do
    echo "  agents/$a.md"
  done

  # Tasks
  echo "  tasks/todo.md"
  echo "  tasks/lessons.md"
  echo "  tasks/tests.md"
  echo "  tasks/session.md"

  # Test dirs
  echo "  tests/unit/"
  echo "  tests/integration/"
  echo "  tests/agent/"
  echo "  scratch/.gitkeep"

  # Language-specific files
  local pkg_name="${PROJECT_NAME//-/_}"
  case "$LANGUAGE" in
    python)
      echo "  pyproject.toml"
      echo "  ruff.toml"
      echo "  conftest.py"
      echo "  src/${pkg_name}/__init__.py"
      case "$ARCHETYPE" in
        cli)      echo "  src/${pkg_name}/cli.py"; echo "  src/${pkg_name}/__main__.py" ;;
        api)      echo "  src/${pkg_name}/app.py"; echo "  src/${pkg_name}/routes/health.py" ;;
        library)  echo "  src/${pkg_name}/lib.py" ;;
      esac
      ;;
    typescript)
      echo "  package.json"
      echo "  tsconfig.json"
      echo "  eslint.config.mjs"
      case "$ARCHETYPE" in
        cli)      echo "  src/cli.ts" ;;
        api)      echo "  src/app.ts"; echo "  src/routes/health.ts" ;;
        *)        echo "  src/index.ts" ;;
      esac
      ;;
    go)
      echo "  go.mod"
      case "$ARCHETYPE" in
        api)      echo "  cmd/${PROJECT_NAME}/main.go"; echo "  internal/routes/health.go" ;;
        library)  echo "  ${pkg_name}.go" ;;
        *)        echo "  cmd/${PROJECT_NAME}/main.go" ;;
      esac
      ;;
    rust)
      echo "  Cargo.toml"
      case "$ARCHETYPE" in
        library)  echo "  src/lib.rs" ;;
        *)        echo "  src/main.rs" ;;
      esac
      ;;
  esac

  # Docker
  if [[ "$ENABLE_DOCKER" == true ]]; then
    echo "  Dockerfile"
    echo "  docker-compose.yml"
  fi

  # VS Code
  if [[ "$ENABLE_VSCODE" == true ]]; then
    echo "  .vscode/settings.json"
    echo "  .vscode/extensions.json"
  fi

  # Ralph
  if [[ "$ENABLE_RALPH" == true ]]; then
    echo "  scripts/ralph-loop.sh"
    echo "  PROMPT_build.md"
    echo "  PROMPT_plan.md"
  fi

  echo ""
  echo -e "${GREEN}No files were written. Run without --dry-run to scaffold.${RESET}"
}

# ---------------------------------------------------------------------------
# Step 1: Project basics
# ---------------------------------------------------------------------------
step_project_basics() {
  header "Project Setup"

  local dir_name
  dir_name="$(basename "$PROJECT_DIR")"

  prompt PROJECT_NAME "Project name" "$dir_name"
  prompt PROJECT_DESC "Short description" "A project built with Claude Code"

  success "Project: $PROJECT_NAME"
}

# ---------------------------------------------------------------------------
# Step 2: Language selection
# ---------------------------------------------------------------------------
step_language() {
  header "Language Selection"

  info "Choose your primary language. This configures:"
  info "  - Language-specific conventions appended to CLAUDE.md"
  info "  - Linter, formatter, type checker, and test runner"
  info "  - Project config files (pyproject.toml, package.json, etc.)"
  echo ""

  prompt_choice LANGUAGE "Select primary language:" \
    "python    â€” pytest, ruff, mypy" \
    "typescript â€” vitest, eslint, tsc" \
    "go        â€” go test, golangci-lint" \
    "rust      â€” cargo test, clippy" \
    "none      â€” language-agnostic (configure later)"

  # Extract just the language name (before the spaces/dash)
  LANGUAGE="${LANGUAGE%% *}"

  if [[ "$LANGUAGE" == "none" ]]; then
    info "No language selected. You can add language support later by copying from templates/."
  else
    success "Language: $LANGUAGE"

    # Show recommendation
    echo ""
    case "$LANGUAGE" in
      python)
        info "${DIM}Recommendation: Use 'uv' or 'pip' with a virtual environment.${RESET}"
        info "${DIM}Run: python -m venv .venv && source .venv/bin/activate && pip install -e '.[dev]'${RESET}"
        ;;
      typescript)
        info "${DIM}Recommendation: Use Node.js 20+ with npm or pnpm.${RESET}"
        info "${DIM}Run: npm install${RESET}"
        ;;
      go)
        info "${DIM}Recommendation: Use Go 1.22+. Install golangci-lint for linting.${RESET}"
        info "${DIM}Run: go mod tidy${RESET}"
        info "${DIM}Note: Update go.mod module path to your full path (e.g., github.com/user/${PROJECT_NAME})${RESET}"
        ;;
      rust)
        info "${DIM}Recommendation: Use the latest stable Rust via rustup.${RESET}"
        info "${DIM}Run: cargo build${RESET}"
        ;;
    esac
  fi
}

# ---------------------------------------------------------------------------
# Step 2b: Project archetype
# ---------------------------------------------------------------------------
step_archetype() {
  # Skip if no language selected â€” archetypes need language context
  if [[ "$LANGUAGE" == "none" ]]; then
    return
  fi

  header "Project Archetype"

  info "Choose an archetype to generate starter project structure."
  info "  This creates entry points, routes, or module layout based on your project type."
  echo ""

  prompt_choice ARCHETYPE "Select project archetype:" \
    "none      â€” blank project (just language tooling)" \
    "cli       â€” command-line tool with argument parsing" \
    "api       â€” web API with routes and health check" \
    "library   â€” reusable library with public API"

  ARCHETYPE="${ARCHETYPE%% *}"

  if [[ "$ARCHETYPE" == "none" ]]; then
    info "No archetype selected. Starting with a blank project."
  else
    success "Archetype: $ARCHETYPE"
  fi
}

# ---------------------------------------------------------------------------
# Step 3: Permissions
# ---------------------------------------------------------------------------
step_permissions() {
  header "Claude Code Permissions"

  info "Safe defaults are always auto-approved:"
  info "  File read/write, searches, git status/diff/log, make targets"
  echo ""
  info "The following need your preference:"
  echo ""

  prompt_yn ALLOW_COMMIT "Auto-approve git commit? (no = Claude asks each time)" true
  prompt_yn ALLOW_PUSH "Auto-approve git push? (no = Claude asks each time)" false
  prompt_yn ALLOW_PKG_MANAGER "Auto-approve package manager commands? (pip/npm/cargo/go)" false
  prompt_yn ALLOW_DOCKER "Auto-approve docker commands?" false

  success "Permissions configured"
}

# ---------------------------------------------------------------------------
# Step 4: Ralph Wiggum
# ---------------------------------------------------------------------------
step_ralph() {
  header "Ralph Wiggum (Autonomous Loop)"

  info "Ralph Wiggum runs Claude Code in iterative cycles:"
  info "  plan â†’ build â†’ test â†’ commit â†’ repeat"
  info "Each iteration gets a fresh context window."
  info "Progress persists via tasks/todo.md."
  echo ""

  prompt_yn ENABLE_RALPH "Enable Ralph Wiggum autonomous loop?" false

  if [[ "$ENABLE_RALPH" == true ]]; then
    success "Ralph Wiggum enabled"
  else
    info "Skipped. You can add Ralph later from templates/ralph/."
  fi
}

step_docker() {
  header "Docker (Optional)"

  prompt_yn ENABLE_DOCKER "Include Dockerfile and docker-compose.yml?" false

  if [[ "$ENABLE_DOCKER" == true ]]; then
    success "Docker enabled"
  else
    info "Skipped. You can add Docker later."
  fi
}

step_vscode() {
  header "VS Code Settings (Optional)"

  prompt_yn ENABLE_VSCODE "Include .vscode/ settings and recommended extensions?" false

  if [[ "$ENABLE_VSCODE" == true ]]; then
    success "VS Code settings enabled"
  else
    info "Skipped. You can add .vscode/ settings later."
  fi
}

# ---------------------------------------------------------------------------
# Step 5: Project planning
# ---------------------------------------------------------------------------
step_planning() {
  header "Project Plan"

  info "A structured plan helps Claude Code understand your project from session one."
  echo ""

  # In dry-run mode, skip file writes â€” just collect info for the report
  if [[ "$DRY_RUN" == true ]]; then
    info "Using blank template. Run '/plan' in Claude Code to create one later."
    return
  fi

  # Ensure tasks/ directory exists before any plan writes
  mkdir -p "$PROJECT_DIR/tasks"

  prompt_choice PLAN_CHOICE "How would you like to set up your project plan?" \
    "Build one now   â€” answer a few questions to generate a plan" \
    "Load from file  â€” import an existing plan (markdown)" \
    "Skip            â€” use the blank template"

  PLAN_CHOICE="${PLAN_CHOICE%% *}"

  case "$PLAN_CHOICE" in
    Build)
      build_plan_interactive
      ;;
    Load)
      load_plan_from_file
      ;;
    Skip)
      info "Using blank template. Run '/plan' in Claude Code to create one later."
      local today
      today=$(date +%Y-%m-%d)
      cat > "$PROJECT_DIR/tasks/todo.md" <<PLAN
# Task Plan â€” ${PROJECT_NAME}

> Created: ${today}
> Status: Not started

## Objective

_Define your project objective here, or run \`/plan\` in Claude Code._

## Plan

- [ ] 1. First task
- [ ] 2. Second task

## Decisions & Context

_Capture architectural decisions and tradeoffs here as you go._

## Results

_Filled in after completion._
PLAN
      ;;
  esac
}

build_plan_interactive() {
  echo ""
  info "Let's build your project plan."
  echo ""

  local objective components milestone risks

  prompt objective "What are you building? (one sentence)" ""
  prompt components "What are the major components or features? (comma-separated)" ""
  prompt milestone "What's the first milestone? (what should work first)" ""
  prompt risks "Any known risks or unknowns?" "None identified yet"

  # Generate structured plan
  local plan_file="$PROJECT_DIR/tasks/todo.md"
  local today
  today=$(date +%Y-%m-%d)

  cat > "$plan_file" <<PLAN
# Task Plan â€” ${PROJECT_NAME}

> Updated: ${today}
> Branch: \`feat/initial-setup\`
> Status: ðŸŸ¡ Planning

---

## Objective

${objective}

## Plan

PLAN

  # Parse components into checkboxes
  local step=1
  if [[ -n "$components" ]]; then
    IFS=',' read -ra COMP_ARRAY <<< "$components"
    for comp in "${COMP_ARRAY[@]}"; do
      comp="$(echo "$comp" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
      if [[ -n "$comp" ]]; then
        echo "- [ ] ${step}. ${comp}" >> "$plan_file"
        step=$((step + 1))
      fi
    done
  fi

  cat >> "$plan_file" <<PLAN

### Checkpoints

- [ ] **Checkpoint 1**: ${milestone}

## Decisions & Context

_Capture architectural decisions and tradeoffs here as you go._

## Risks

- ${risks}

## Results

_Filled in after completion._
PLAN

  success "Plan written to tasks/todo.md"
}

load_plan_from_file() {
  echo ""
  local plan_path
  prompt plan_path "Path to your plan file" ""

  if [[ -z "$plan_path" ]]; then
    warn "No path provided. Using blank template."
    return
  fi

  # Expand ~ to home directory
  plan_path="${plan_path/#\~/$HOME}"

  if [[ ! -f "$plan_path" ]]; then
    warn "File not found: $plan_path. Using blank template."
    return
  fi

  cp "$plan_path" "$PROJECT_DIR/tasks/todo.md"
  success "Plan loaded from $plan_path"
}

# ---------------------------------------------------------------------------
# Step 6: Git remote
# ---------------------------------------------------------------------------
step_git_remote() {
  header "Git Remote (Optional)"

  prompt GIT_REMOTE "Git remote URL (leave blank to skip)" ""

  if [[ -n "$GIT_REMOTE" ]]; then
    success "Remote: $GIT_REMOTE"
  fi
}

# ---------------------------------------------------------------------------
# Step 7: GitHub Project Management
# ---------------------------------------------------------------------------
step_github_pm() {
  header "GitHub Project Management"

  info "Issue templates and PR template are included in .github/"

  if [[ -z "$GIT_REMOTE" ]]; then
    info "No git remote set. Run 'make setup-github' when your remote is ready."
    return
  fi

  if ! command -v gh &>/dev/null; then
    info "GitHub CLI (gh) not found. Install it and run 'make setup-github' to set up labels."
    return
  fi

  if ! gh auth status &>/dev/null 2>&1; then
    info "GitHub CLI not authenticated. Run 'gh auth login' then 'make setup-github'."
    return
  fi

  prompt_yn SETUP_LABELS "Create issue labels (type, priority, status)?" true
  prompt_yn SETUP_KANBAN "Create a GitHub Projects kanban board?" false
}

extract_repo_from_remote() {
  local url="$GIT_REMOTE"
  # Handle SSH: git@github.com:user/repo.git
  if [[ "$url" == git@github.com:* ]]; then
    url="${url#git@github.com:}"
    url="${url%.git}"
    echo "$url"
    return
  fi
  # Handle HTTPS: https://github.com/user/repo.git
  if [[ "$url" == https://github.com/* ]]; then
    url="${url#https://github.com/}"
    url="${url%.git}"
    echo "$url"
    return
  fi
  echo ""
}

create_github_labels() {
  info "Creating issue labels..."
  local repo
  repo="$(extract_repo_from_remote)"
  if [[ -z "$repo" ]]; then
    warn "Could not determine GitHub repo from remote URL."
    return
  fi

  # Type labels
  gh label create "bug" --color "d73a4a" --description "Something isn't working" --repo "$repo" --force 2>/dev/null || true
  gh label create "feature" --color "0075ca" --description "New feature or enhancement" --repo "$repo" --force 2>/dev/null || true
  gh label create "task" --color "0e8a16" --description "Development task or chore" --repo "$repo" --force 2>/dev/null || true
  gh label create "chore" --color "e4e669" --description "Maintenance or cleanup" --repo "$repo" --force 2>/dev/null || true
  gh label create "refactor" --color "d4c5f9" --description "Code restructuring, no behavior change" --repo "$repo" --force 2>/dev/null || true

  # Priority labels
  gh label create "P0-critical" --color "b60205" --description "Drop everything" --repo "$repo" --force 2>/dev/null || true
  gh label create "P1-high" --color "d93f0b" --description "Fix this sprint" --repo "$repo" --force 2>/dev/null || true
  gh label create "P2-medium" --color "fbca04" --description "Plan for next sprint" --repo "$repo" --force 2>/dev/null || true
  gh label create "P3-low" --color "c5def5" --description "Nice to have" --repo "$repo" --force 2>/dev/null || true

  # Status labels
  gh label create "needs-triage" --color "f9d0c4" --description "Needs review and prioritization" --repo "$repo" --force 2>/dev/null || true
  gh label create "ready" --color "0e8a16" --description "Ready to be picked up" --repo "$repo" --force 2>/dev/null || true
  gh label create "blocked" --color "b60205" --description "Waiting on external dependency" --repo "$repo" --force 2>/dev/null || true
  gh label create "in-progress" --color "1d76db" --description "Currently being worked on" --repo "$repo" --force 2>/dev/null || true

  success "Labels created (type, priority, status)"
}

create_github_project() {
  info "Creating GitHub Projects kanban board..."
  local repo
  repo="$(extract_repo_from_remote)"
  local owner="${repo%%/*}"

  local project_url
  project_url="$(gh project create --title "${PROJECT_NAME}" --owner "$owner" 2>/dev/null)" || true

  if [[ -n "$project_url" ]]; then
    success "Kanban board created: $project_url"
  else
    warn "Could not create project board. Create one manually at https://github.com/${repo}/projects"
  fi
}

apply_github_pm() {
  if [[ "$SETUP_LABELS" != true && "$SETUP_KANBAN" != true ]]; then
    return
  fi

  header "Setting Up GitHub Project Management"

  # Push to remote first so labels can be created
  if [[ -n "$GIT_REMOTE" ]]; then
    info "Pushing to remote..."
    git -C "$PROJECT_DIR" push -u origin main 2>/dev/null || true
  fi

  if ! command -v gh &>/dev/null || ! gh auth status &>/dev/null 2>&1; then
    info "GitHub CLI not available. Run 'make setup-github' to create labels and project board."
    return
  fi

  if [[ "$SETUP_LABELS" == true ]]; then
    create_github_labels
  fi

  if [[ "$SETUP_KANBAN" == true ]]; then
    create_github_project
  fi
}

# ---------------------------------------------------------------------------
# Apply: Archetype-specific project structure
# ---------------------------------------------------------------------------
apply_archetype() {
  local escaped_name="$1"
  local pkg_name="${PROJECT_NAME//-/_}"

  info "Creating project structure (archetype: $ARCHETYPE)..."

  case "$LANGUAGE" in
    python)
      mkdir -p "$PROJECT_DIR/src/$pkg_name"
      touch "$PROJECT_DIR/src/$pkg_name/__init__.py"

      case "$ARCHETYPE" in
        cli)
          cat > "$PROJECT_DIR/src/$pkg_name/__main__.py" <<PYEOF
"""Allow running as: python -m $pkg_name"""
from ${pkg_name}.cli import main

if __name__ == "__main__":
    main()
PYEOF
          cat > "$PROJECT_DIR/src/$pkg_name/cli.py" <<'PYEOF'
"""Command-line interface for {{PROJECT_NAME}}."""
import argparse
import sys


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="{{PROJECT_NAME}}",
        description="{{PROJECT_DESC}}",
    )
    parser.add_argument("--version", action="version", version="%(prog)s 0.1.0")

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Example subcommand â€” replace with your own
    run_parser = subparsers.add_parser("run", help="Run the main task")
    run_parser.add_argument("target", nargs="?", default="world", help="Target to process")

    return parser


def main(argv: list[str] | None = None) -> None:
    parser = build_parser()
    args = parser.parse_args(argv)

    if args.command is None:
        parser.print_help()
        sys.exit(0)

    if args.command == "run":
        print(f"Running with target: {args.target}")
PYEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/$pkg_name/cli.py"
          sed_inplace "s/{{PROJECT_DESC}}/${PROJECT_DESC//\//\\/}/g" "$PROJECT_DIR/src/$pkg_name/cli.py"
          success "  Created CLI archetype: src/$pkg_name/cli.py, __main__.py"
          ;;
        api)
          mkdir -p "$PROJECT_DIR/src/$pkg_name/routes"
          touch "$PROJECT_DIR/src/$pkg_name/routes/__init__.py"
          cat > "$PROJECT_DIR/src/$pkg_name/app.py" <<'PYEOF'
"""{{PROJECT_NAME}} â€” API application."""
from http.server import HTTPServer

from {{PKG_NAME}}.routes.health import HealthHandler


def create_app(host: str = "0.0.0.0", port: int = 8000) -> HTTPServer:
    """Create and return the HTTP server."""
    server = HTTPServer((host, port), HealthHandler)
    return server


def main() -> None:
    """Start the development server."""
    server = create_app()
    print(f"Server running on http://localhost:{server.server_address[1]}")
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down.")
        server.server_close()


if __name__ == "__main__":
    main()
PYEOF
          cat > "$PROJECT_DIR/src/$pkg_name/routes/health.py" <<'PYEOF'
"""Health check endpoint."""
import json
from http.server import BaseHTTPRequestHandler


class HealthHandler(BaseHTTPRequestHandler):
    """Handle HTTP requests."""

    def do_GET(self) -> None:
        if self.path == "/health":
            self._json_response(200, {"status": "ok"})
        else:
            self._json_response(404, {"error": "not found"})

    def _json_response(self, status: int, body: dict) -> None:
        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(json.dumps(body).encode())
PYEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/$pkg_name/app.py"
          sed_inplace "s/{{PKG_NAME}}/${pkg_name}/g" "$PROJECT_DIR/src/$pkg_name/app.py"
          success "  Created API archetype: src/$pkg_name/app.py, routes/health.py"
          ;;
        library)
          cat > "$PROJECT_DIR/src/$pkg_name/lib.py" <<'PYEOF'
"""{{PROJECT_NAME}} â€” public API."""


def hello(name: str = "world") -> str:
    """Return a greeting. Replace with your library's public API."""
    return f"Hello, {name}!"
PYEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/$pkg_name/lib.py"
          success "  Created library archetype: src/$pkg_name/lib.py"
          ;;
        *)
          success "  Created src/$pkg_name/"
          ;;
      esac
      ;;

    typescript)
      mkdir -p "$PROJECT_DIR/src"

      case "$ARCHETYPE" in
        cli)
          cat > "$PROJECT_DIR/src/cli.ts" <<'TSEOF'
/**
 * CLI entry point for {{PROJECT_NAME}}.
 */

interface ParsedArgs {
  command: string | null;
  target: string;
  flags: Record<string, boolean>;
}

function parseArgs(argv: string[]): ParsedArgs {
  const args = argv.slice(2);
  const flags: Record<string, boolean> = {};
  const positional: string[] = [];

  for (const arg of args) {
    if (arg.startsWith("--")) {
      flags[arg.slice(2)] = true;
    } else {
      positional.push(arg);
    }
  }

  return {
    command: positional[0] ?? null,
    target: positional[1] ?? "world",
    flags,
  };
}

function main(): void {
  const { command, target, flags } = parseArgs(process.argv);

  if (flags.version) {
    console.log("{{PROJECT_NAME}} 0.1.0");
    return;
  }

  if (flags.help || command === null) {
    console.log("Usage: {{PROJECT_NAME}} <command> [target]");
    console.log("");
    console.log("Commands:");
    console.log("  run [target]  Run the main task");
    return;
  }

  if (command === "run") {
    console.log(`Running with target: ${target}`);
  }
}

main();
TSEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/cli.ts"
          success "  Created CLI archetype: src/cli.ts"
          ;;
        api)
          mkdir -p "$PROJECT_DIR/src/routes"
          cat > "$PROJECT_DIR/src/app.ts" <<'TSEOF'
/**
 * {{PROJECT_NAME}} â€” API application.
 */
import { createServer, IncomingMessage, ServerResponse } from "node:http";
import { healthHandler } from "./routes/health.js";

const PORT = parseInt(process.env.PORT ?? "3000", 10);

function router(req: IncomingMessage, res: ServerResponse): void {
  if (req.url === "/health" && req.method === "GET") {
    healthHandler(req, res);
  } else {
    res.writeHead(404, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ error: "not found" }));
  }
}

const server = createServer(router);

server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
TSEOF
          cat > "$PROJECT_DIR/src/routes/health.ts" <<'TSEOF'
/**
 * Health check endpoint.
 */
import { IncomingMessage, ServerResponse } from "node:http";

export function healthHandler(_req: IncomingMessage, res: ServerResponse): void {
  res.writeHead(200, { "Content-Type": "application/json" });
  res.end(JSON.stringify({ status: "ok" }));
}
TSEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/app.ts"
          success "  Created API archetype: src/app.ts, src/routes/health.ts"
          ;;
        library)
          cat > "$PROJECT_DIR/src/index.ts" <<'TSEOF'
/**
 * {{PROJECT_NAME}} â€” public API.
 */

/**
 * Return a greeting. Replace with your library's public API.
 */
export function hello(name: string = "world"): string {
  return `Hello, ${name}!`;
}
TSEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/index.ts"
          success "  Created library archetype: src/index.ts"
          ;;
        *)
          cat > "$PROJECT_DIR/src/index.ts" <<'TSEOF'
export function main(): void {
  console.log("Hello from {{PROJECT_NAME}}");
}
TSEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/index.ts"
          success "  Created src/index.ts"
          ;;
      esac
      ;;

    go)
      case "$ARCHETYPE" in
        cli)
          mkdir -p "$PROJECT_DIR/cmd/$PROJECT_NAME"
          cat > "$PROJECT_DIR/cmd/$PROJECT_NAME/main.go" <<'GOEOF'
package main

import (
	"fmt"
	"os"
)

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(0)
	}

	switch os.Args[1] {
	case "run":
		target := "world"
		if len(os.Args) > 2 {
			target = os.Args[2]
		}
		fmt.Printf("Running with target: %s\n", target)
	case "--version":
		fmt.Println("{{PROJECT_NAME}} 0.1.0")
	case "--help":
		printUsage()
	default:
		fmt.Fprintf(os.Stderr, "Unknown command: %s\n", os.Args[1])
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Println("Usage: {{PROJECT_NAME}} <command> [target]")
	fmt.Println("")
	fmt.Println("Commands:")
	fmt.Println("  run [target]  Run the main task")
}
GOEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/cmd/$PROJECT_NAME/main.go"
          success "  Created CLI archetype: cmd/$PROJECT_NAME/main.go"
          ;;
        api)
          mkdir -p "$PROJECT_DIR/cmd/$PROJECT_NAME"
          mkdir -p "$PROJECT_DIR/internal/routes"
          cat > "$PROJECT_DIR/cmd/$PROJECT_NAME/main.go" <<'GOEOF'
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"{{PROJECT_NAME}}/internal/routes"
)

func main() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	mux := http.NewServeMux()
	mux.HandleFunc("GET /health", routes.HealthHandler)

	fmt.Printf("Server running on http://localhost:%s\n", port)
	log.Fatal(http.ListenAndServe(":"+port, mux))
}
GOEOF
          cat > "$PROJECT_DIR/internal/routes/health.go" <<'GOEOF'
package routes

import (
	"encoding/json"
	"net/http"
)

// HealthHandler returns the health status of the service.
func HealthHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}
GOEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/cmd/$PROJECT_NAME/main.go"
          success "  Created API archetype: cmd/$PROJECT_NAME/main.go, internal/routes/health.go"
          ;;
        library)
          cat > "$PROJECT_DIR/${pkg_name}.go" <<'GOEOF'
// Package {{PKG_NAME}} provides the public API.
package {{PKG_NAME}}

// Hello returns a greeting. Replace with your library's public API.
func Hello(name string) string {
	if name == "" {
		name = "world"
	}
	return "Hello, " + name + "!"
}
GOEOF
          sed_inplace "s/{{PKG_NAME}}/${pkg_name}/g" "$PROJECT_DIR/${pkg_name}.go"
          success "  Created library archetype: ${pkg_name}.go"
          ;;
        *)
          mkdir -p "$PROJECT_DIR/cmd/$PROJECT_NAME"
          cat > "$PROJECT_DIR/cmd/$PROJECT_NAME/main.go" <<'GOEOF'
package main

import "fmt"

func main() {
	fmt.Println("Hello from {{PROJECT_NAME}}")
}
GOEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/cmd/$PROJECT_NAME/main.go"
          success "  Created cmd/$PROJECT_NAME/main.go"
          ;;
      esac
      ;;

    rust)
      mkdir -p "$PROJECT_DIR/src"

      case "$ARCHETYPE" in
        cli)
          cat > "$PROJECT_DIR/src/main.rs" <<'RSEOF'
//! CLI entry point for {{PROJECT_NAME}}.
use std::env;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        print_usage();
        process::exit(0);
    }

    match args[1].as_str() {
        "run" => {
            let target = args.get(2).map(|s| s.as_str()).unwrap_or("world");
            println!("Running with target: {target}");
        }
        "--version" => println!("{{PROJECT_NAME}} 0.1.0"),
        "--help" => print_usage(),
        cmd => {
            eprintln!("Unknown command: {cmd}");
            process::exit(1);
        }
    }
}

fn print_usage() {
    println!("Usage: {{PROJECT_NAME}} <command> [target]");
    println!();
    println!("Commands:");
    println!("  run [target]  Run the main task");
}
RSEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/main.rs"
          success "  Created CLI archetype: src/main.rs"
          ;;
        api)
          cat > "$PROJECT_DIR/src/main.rs" <<'RSEOF'
//! {{PROJECT_NAME}} â€” API server.
use std::io::Write;
use std::net::TcpListener;

fn main() {
    let port = std::env::var("PORT").unwrap_or_else(|_| "8080".to_string());
    let addr = format!("0.0.0.0:{port}");
    let listener = TcpListener::bind(&addr).expect("Failed to bind");
    println!("Server running on http://localhost:{port}");

    for stream in listener.incoming() {
        if let Ok(mut stream) = stream {
            let response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"status\":\"ok\"}";
            let _ = stream.write_all(response.as_bytes());
        }
    }
}
RSEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/main.rs"
          success "  Created API archetype: src/main.rs"
          ;;
        library)
          cat > "$PROJECT_DIR/src/lib.rs" <<'RSEOF'
//! {{PROJECT_NAME}} â€” public API.

/// Return a greeting. Replace with your library's public API.
pub fn hello(name: &str) -> String {
    if name.is_empty() {
        return "Hello, world!".to_string();
    }
    format!("Hello, {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hello_with_name() {
        assert_eq!(hello("Rust"), "Hello, Rust!");
    }

    #[test]
    fn test_hello_empty() {
        assert_eq!(hello(""), "Hello, world!");
    }
}
RSEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/lib.rs"
          # Remove default main.rs for library archetype
          success "  Created library archetype: src/lib.rs"
          ;;
        *)
          cat > "$PROJECT_DIR/src/main.rs" <<'RSEOF'
fn main() {
    println!("Hello from {{PROJECT_NAME}}");
}
RSEOF
          sed_inplace "s/{{PROJECT_NAME}}/${escaped_name}/g" "$PROJECT_DIR/src/main.rs"
          success "  Created src/main.rs"
          ;;
      esac
      ;;
  esac
}

# ---------------------------------------------------------------------------
# Apply: Language-specific configuration
# ---------------------------------------------------------------------------
apply_language_config() {
  # --- Append language conventions to CLAUDE.md (before placeholder replacement) ---
  if [[ "$LANGUAGE" != "none" && -f "$TEMPLATE_DIR/$LANGUAGE/CONVENTIONS.md" ]]; then
    info "Appending $LANGUAGE conventions to CLAUDE.md..."
    { echo ""; echo "---"; echo ""; cat "$TEMPLATE_DIR/$LANGUAGE/CONVENTIONS.md"; } >> "$PROJECT_DIR/CLAUDE.md"
    success "CLAUDE.md updated with $LANGUAGE conventions"
  fi

  # --- Replace placeholders in CLAUDE.md (after conventions are appended) ---
  info "Customizing CLAUDE.md..."
  replace_placeholders "$PROJECT_DIR/CLAUDE.md"

  # --- Place language-specific config files ---
  if [[ "$LANGUAGE" != "none" ]]; then
    info "Installing $LANGUAGE config files..."

    local tmpl_dir="$TEMPLATE_DIR/$LANGUAGE"
    local escaped_name escaped_desc
    escaped_name="$(sed_escape "$PROJECT_NAME")"
    escaped_desc="$(sed_escape "$PROJECT_DESC")"

    # Process .tmpl files (replace placeholders, remove .tmpl extension)
    for tmpl in "$tmpl_dir"/*.tmpl; do
      if [[ -f "$tmpl" ]]; then
        local dest_name
        dest_name="$(basename "$tmpl" .tmpl)"
        sed "s/{{PROJECT_NAME}}/${escaped_name}/g; s/{{PROJECT_DESCRIPTION}}/${escaped_desc}/g" \
          "$tmpl" > "$PROJECT_DIR/$dest_name"
        success "  Created $dest_name"
      fi
    done

    # Copy non-template config files (not CONVENTIONS.md, not .tmpl, not gitignore.append)
    for cfg in "$tmpl_dir"/*; do
      local basename
      basename="$(basename "$cfg")"
      if [[ "$basename" != "CONVENTIONS.md" && \
            "$basename" != "gitignore.append" && \
            "$basename" != *.tmpl && \
            -f "$cfg" ]]; then
        cp "$cfg" "$PROJECT_DIR/$basename"
        success "  Created $basename"
      fi
    done

    # Append language-specific gitignore entries
    if [[ -f "$tmpl_dir/gitignore.append" ]]; then
      cat "$tmpl_dir/gitignore.append" >> "$PROJECT_DIR/.gitignore"
      success "  Updated .gitignore with $LANGUAGE entries"
    fi

    # Create src directory + archetype files
    apply_archetype "$escaped_name"
  fi
}

# ---------------------------------------------------------------------------
# Apply: Common project files
# ---------------------------------------------------------------------------
apply_common_files() {
  # --- Generate project README (replaces scaffold README) ---
  info "Generating project README..."
  local getting_started=""
  case "$LANGUAGE" in
    python)
      getting_started="# Set up virtual environment
python -m venv .venv
source .venv/bin/activate
pip install -e '.[dev]'" ;;
    typescript)
      getting_started="# Install dependencies
npm install" ;;
    go)
      getting_started="# Install dependencies
go mod tidy" ;;
    rust)
      getting_started="# Build
cargo build" ;;
    *)
      getting_started="# Install dependencies (configure for your language)" ;;
  esac

  # Build badges line
  local badges=""
  local lang_badge=""
  case "$LANGUAGE" in
    python)     lang_badge="![Python](https://img.shields.io/badge/python-3.12-blue.svg)" ;;
    typescript) lang_badge="![TypeScript](https://img.shields.io/badge/typescript-5.x-blue.svg)" ;;
    go)         lang_badge="![Go](https://img.shields.io/badge/go-1.22-blue.svg)" ;;
    rust)       lang_badge="![Rust](https://img.shields.io/badge/rust-stable-blue.svg)" ;;
  esac
  badges="![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)"
  if [[ -n "$lang_badge" ]]; then
    badges="$badges $lang_badge"
  fi
  if [[ -n "$GIT_REMOTE" ]]; then
    # Extract owner/repo from remote URL for CI badge
    local repo_slug
    repo_slug="$(echo "$GIT_REMOTE" | sed -E 's|.*[:/]([^/]+/[^/]+?)(\.git)?$|\1|')"
    badges="![CI](https://github.com/${repo_slug}/actions/workflows/ci.yml/badge.svg) $badges"
  fi

  cat > "$PROJECT_DIR/README.md" <<README
# ${PROJECT_NAME}

${badges}

${PROJECT_DESC}

## Getting Started

\`\`\`bash
${getting_started}

# Run tests
make test
\`\`\`

## Development

| Command | Description |
|---------|-------------|
| \`make test\` | Run all test tiers |
| \`make lint\` | Run linter |
| \`make fmt\` | Auto-format code |
| \`make typecheck\` | Run type checker |
| \`make build\` | Compile/build |
| \`make check\` | lint + typecheck + test (pre-PR gate) |

### Claude Code

This project is configured for [Claude Code](https://docs.anthropic.com/en/docs/claude-code) with:

- Agent constitution (\`CLAUDE.md\`)
- 14 slash commands: \`/start\`, \`/plan\`, \`/review\`, \`/test\`, \`/refactor\`, \`/backlog\`, \`/doctor\`, \`/lesson\`, \`/checkpoint\`, \`/status\`, \`/simplify\`, \`/index\`, \`/save\`, \`/load\`
- 8 agent specifications in \`agents/\`
- Task management in \`tasks/\`

## License

[MIT](LICENSE)
README
  success "README.md generated for ${PROJECT_NAME}"

  # --- Generate GETTING_STARTED.md (first-session onboarding guide) ---
  info "Generating getting started guide..."
  local env_setup=""
  case "$LANGUAGE" in
    python)
      env_setup="### Set Up Your Environment

\`\`\`bash
python -m venv .venv
source .venv/bin/activate
pip install -e '.[dev]'
\`\`\`" ;;
    typescript)
      env_setup="### Set Up Your Environment

\`\`\`bash
npm install
\`\`\`" ;;
    go)
      env_setup="### Set Up Your Environment

\`\`\`bash
go mod tidy
\`\`\`" ;;
    rust)
      env_setup="### Set Up Your Environment

\`\`\`bash
cargo build
\`\`\`" ;;
    *)
      env_setup="### Set Up Your Environment

Install dependencies for your chosen language, then come back here." ;;
  esac

  cat > "$PROJECT_DIR/GETTING_STARTED.md" <<GUIDE
# Getting Started with ${PROJECT_NAME}

Welcome! This guide walks you through your first 10 minutes with Claude Code.

## Step 1: Set Up

${env_setup}

## Step 2: Launch Claude Code

\`\`\`bash
claude
\`\`\`

## Step 3: Start Building

The easiest way to get going is to type:

\`\`\`
/start
\`\`\`

This will walk you through creating your first plan and (optionally) your first GitHub issue.

**Or, if you already know what you want to build**, just tell Claude:

\`\`\`
I want to build [your idea here]. Help me create a plan.
\`\`\`

Claude will create a structured plan in \`tasks/todo.md\` and ask for your approval before writing any code.

## Step 4: Build

Once your plan is approved, tell Claude to start:

\`\`\`
Let's start on step 1.
\`\`\`

Claude will work through the plan step by step, committing as it goes. You stay in control â€” it will check in at each step.

## Your Toolkit

Here are the commands you'll use most:

| Command | What It Does | When to Use It |
|---------|-------------|----------------|
| \`/start\` | Guided first-session setup | Right now (first time only) |
| \`/plan\` | Create or refine a project plan | Starting a new feature or task |
| \`/status\` | See progress and what's next | Any time you lose track |
| \`/backlog show\` | See open GitHub issues by priority | Picking what to work on |
| \`/backlog pick #N\` | Start working on issue #N | Beginning a task |
| \`/checkpoint\` | Commit progress and update plan | After completing a step |
| \`/test\` | Run tests and analyze results | Before committing |
| \`/save\` | Save session state for later | Ending a session |
| \`/load\` | Restore previous session context | Starting a new session |
| \`/lesson\` | Record what you learned | After fixing a tricky bug |

## How It Works

Your project has a few key files that Claude reads automatically:

- **\`CLAUDE.md\`** â€” The "rules" for how Claude works in your project (commit conventions, testing requirements, safety guardrails)
- **\`tasks/todo.md\`** â€” Your current plan and progress
- **\`tasks/lessons.md\`** â€” Things Claude learned from past sessions (mistakes to avoid, patterns that work)

You don't need to read these files â€” Claude uses them behind the scenes. But feel free to peek if you're curious.

## Tips

- **Be specific.** "Build a REST API for managing todos with CRUD endpoints" works better than "build something."
- **Let Claude plan first.** It will create a step-by-step plan before writing code. Review and approve it.
- **Commit often.** Use \`/checkpoint\` after each working piece. Small commits are easier to review and revert.
- **Ask questions.** Claude will ask you when it needs clarification. You can also ask it anything about the code.
GUIDE
  success "GETTING_STARTED.md generated"

  # --- Generate CI workflow ---
  info "Generating CI workflow..."
  mkdir -p "$PROJECT_DIR/.github/workflows"

  local ci_setup=""
  case "$LANGUAGE" in
    python)
      ci_setup="
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m venv .venv
          source .venv/bin/activate
          pip install -e '.[dev]'" ;;
    typescript)
      ci_setup="
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci" ;;
    go)
      ci_setup="
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'" ;;
    rust)
      ci_setup="
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt" ;;
    *)
      ci_setup="" ;;
  esac

  cat > "$PROJECT_DIR/.github/workflows/ci.yml" <<CIEOF
name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  check:
    name: Lint, typecheck, and test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
${ci_setup}

      - name: Run checks
        run: make check
CIEOF
  success "CI workflow generated (.github/workflows/ci.yml)"

  # --- Generate .env.example ---
  info "Generating .env.example..."
  cat > "$PROJECT_DIR/.env.example" <<'ENVEOF'
# Environment variables for this project
# Copy to .env and fill in values: cp .env.example .env
# NEVER commit .env â€” it's in .gitignore

# Example:
# DATABASE_URL=postgresql://localhost:5432/mydb
# API_KEY=your-api-key-here
ENVEOF
  success ".env.example generated"

  # --- Generate CHANGELOG.md ---
  info "Generating CHANGELOG.md..."
  cat > "$PROJECT_DIR/CHANGELOG.md" <<CHLOG
# Changelog

All notable changes to ${PROJECT_NAME} will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/),
and this project adheres to [Semantic Versioning](https://semver.org/).

## [Unreleased]

### Added
- Initial project setup with scaffold framework
CHLOG
  success "CHANGELOG.md generated"

  # --- Generate SECURITY.md ---
  info "Generating SECURITY.md..."
  cat > "$PROJECT_DIR/SECURITY.md" <<'SECEOF'
# Security Policy

## Supported Versions

| Version | Supported |
|---------|-----------|
| latest  | Yes       |

## Reporting a Vulnerability

If you discover a security vulnerability, please report it responsibly:

1. **Do not** open a public GitHub issue
2. Email the maintainers or use [GitHub's private vulnerability reporting](https://docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability)
3. Include a description of the vulnerability, steps to reproduce, and potential impact
4. Allow up to 72 hours for an initial response

## Scope

This policy applies to the latest version of this project. We take all security reports seriously and will investigate promptly.

## Disclosure

We follow coordinated disclosure. We will work with you to understand and address the issue before any public disclosure.
SECEOF
  success "SECURITY.md generated"

  # --- Generate pre-commit config ---
  info "Generating pre-commit config..."
  local precommit_hooks=""
  case "$LANGUAGE" in
    python)
      precommit_hooks="  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.4.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format" ;;
    typescript)
      precommit_hooks="  - repo: local
    hooks:
      - id: eslint
        name: eslint
        entry: npx eslint --fix
        language: system
        types: [ts, tsx, js, jsx]" ;;
    go)
      precommit_hooks="  - repo: https://github.com/golangci/golangci-lint
    rev: v1.59.0
    hooks:
      - id: golangci-lint" ;;
    rust)
      precommit_hooks="  - repo: local
    hooks:
      - id: cargo-fmt
        name: cargo fmt
        entry: cargo fmt --
        language: system
        types: [rust]
      - id: cargo-clippy
        name: cargo clippy
        entry: cargo clippy -- -D warnings
        language: system
        types: [rust]
        pass_filenames: false" ;;
    *)
      precommit_hooks="" ;;
  esac

  cat > "$PROJECT_DIR/.pre-commit-config.yaml" <<PCEOF
# Pre-commit hooks â€” run automatically before each commit
# Install: pip install pre-commit && pre-commit install
# Manual run: pre-commit run --all-files
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
        args: ['--maxkb=500']
      - id: detect-private-key
      - id: check-merge-conflict
${precommit_hooks}
  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.5.0
    hooks:
      - id: detect-secrets
        args: ['--baseline', '.secrets.baseline']
PCEOF
  success "Pre-commit config generated (.pre-commit-config.yaml)"

  # --- Generate release workflow ---
  info "Generating release workflow..."
  cat > "$PROJECT_DIR/.github/workflows/release.yml" <<'RLEOF'
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract changelog for this version
        id: changelog
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          # Extract section for this version from CHANGELOG.md
          NOTES=$(awk "/^## \[${VERSION}\]/{flag=1; next} /^## \[/{flag=0} flag" CHANGELOG.md)
          if [ -z "$NOTES" ]; then
            NOTES="Release ${GITHUB_REF_NAME}"
          fi
          {
            echo 'notes<<EOF'
            echo "$NOTES"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          TAG_NAME: ${{ github.ref_name }}
          RELEASE_NOTES: ${{ steps.changelog.outputs.notes }}
        run: |
          gh release create "$TAG_NAME" \
            --title "$TAG_NAME" \
            --notes "$RELEASE_NOTES"
RLEOF
  success "Release workflow generated (.github/workflows/release.yml)"
}

# ---------------------------------------------------------------------------
# Apply: Optional features (Ralph, Docker, VS Code)
# ---------------------------------------------------------------------------
apply_optional_features() {
  # --- Ralph Wiggum ---
  if [[ "$ENABLE_RALPH" == true ]]; then
    info "Setting up Ralph Wiggum..."
    mkdir -p "$PROJECT_DIR/scripts"
    cp "$TEMPLATE_DIR/ralph/ralph-loop.sh" "$PROJECT_DIR/scripts/ralph-loop.sh"
    chmod +x "$PROJECT_DIR/scripts/ralph-loop.sh"
    cp "$TEMPLATE_DIR/ralph/PROMPT_build.md" "$PROJECT_DIR/PROMPT_build.md"
    cp "$TEMPLATE_DIR/ralph/PROMPT_plan.md" "$PROJECT_DIR/PROMPT_plan.md"
    success "Ralph Wiggum installed (scripts/ralph-loop.sh)"
  fi

  # --- Generate Docker files (if enabled) ---
  if [[ "$ENABLE_DOCKER" == true ]]; then
    info "Generating Docker files..."

    case "$LANGUAGE" in
      python)
        cat > "$PROJECT_DIR/Dockerfile" <<'DKEOF'
FROM python:3.12-slim AS base

WORKDIR /app

COPY pyproject.toml ./
RUN pip install --no-cache-dir .

COPY src/ ./src/

EXPOSE 8000
CMD ["python", "-m", "uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
DKEOF
        ;;
      typescript)
        cat > "$PROJECT_DIR/Dockerfile" <<'DKEOF'
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./

EXPOSE 3000
CMD ["node", "dist/index.js"]
DKEOF
        ;;
      go)
        cat > "$PROJECT_DIR/Dockerfile" <<'DKEOF'
FROM golang:1.22-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 go build -o /bin/app ./cmd/

FROM alpine:3.19
RUN apk add --no-cache ca-certificates
COPY --from=builder /bin/app /bin/app

EXPOSE 8080
CMD ["/bin/app"]
DKEOF
        ;;
      rust)
        cat > "$PROJECT_DIR/Dockerfile" <<'DKEOF'
FROM rust:1.78-slim AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs && cargo build --release && rm -rf src
COPY src/ ./src/
RUN touch src/main.rs && cargo build --release

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y --no-install-recommends ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/app /usr/local/bin/app

EXPOSE 8080
CMD ["app"]
DKEOF
        ;;
      *)
        cat > "$PROJECT_DIR/Dockerfile" <<'DKEOF'
FROM ubuntu:22.04

WORKDIR /app
COPY . .

# Configure for your language
# RUN apt-get update && apt-get install -y ...

EXPOSE 8080
CMD ["echo", "Configure this Dockerfile for your project"]
DKEOF
        ;;
    esac

    cat > "$PROJECT_DIR/docker-compose.yml" <<DCEOF
services:
  app:
    build: .
    ports:
      - "8080:8080"
    env_file:
      - .env
    volumes:
      - .:/app
    # Uncomment for development with hot reload:
    # command: ["your-dev-command-here"]

  # Add services as needed:
  # db:
  #   image: postgres:16-alpine
  #   environment:
  #     POSTGRES_DB: ${PROJECT_NAME}
  #     POSTGRES_USER: postgres
  #     POSTGRES_PASSWORD: postgres
  #   ports:
  #     - "5432:5432"
  #   volumes:
  #     - db_data:/var/lib/postgresql/data

# volumes:
#   db_data:
DCEOF
    success "Docker files generated (Dockerfile, docker-compose.yml)"
  fi

  # --- Generate VS Code settings ---
  if [[ "$ENABLE_VSCODE" == true ]]; then
    info "Generating VS Code settings..."
    mkdir -p "$PROJECT_DIR/.vscode"

    # settings.json â€” per language
    local vscode_settings=""
    case "$LANGUAGE" in
      python)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [88],
  "editor.tabSize": 4,
  "[python]": {
    "editor.defaultFormatter": "charliermarsh.ruff",
    "editor.codeActionsOnSave": {
      "source.fixAll.ruff": "explicit",
      "source.organizeImports.ruff": "explicit"
    }
  },
  "python.testing.pytestEnabled": true,
  "python.testing.pytestArgs": ["tests"]
}' ;;
      typescript)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [100],
  "editor.tabSize": 2,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[typescriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "typescript.preferences.importModuleSpecifier": "relative"
}' ;;
      go)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [100],
  "editor.tabSize": 4,
  "[go]": {
    "editor.defaultFormatter": "golang.go"
  },
  "go.lintTool": "golangci-lint",
  "go.lintOnSave": "workspace",
  "go.testFlags": ["-v"]
}' ;;
      rust)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [100],
  "editor.tabSize": 4,
  "[rust]": {
    "editor.defaultFormatter": "rust-lang.rust-analyzer"
  },
  "rust-analyzer.check.command": "clippy"
}' ;;
      *)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [100],
  "editor.tabSize": 2
}' ;;
    esac
    echo "$vscode_settings" > "$PROJECT_DIR/.vscode/settings.json"

    # extensions.json â€” per language
    local vscode_extensions=""
    case "$LANGUAGE" in
      python)
        vscode_extensions='{
  "recommendations": [
    "charliermarsh.ruff",
    "ms-python.python",
    "ms-python.vscode-pylance"
  ]
}' ;;
      typescript)
        vscode_extensions='{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode"
  ]
}' ;;
      go)
        vscode_extensions='{
  "recommendations": [
    "golang.go"
  ]
}' ;;
      rust)
        vscode_extensions='{
  "recommendations": [
    "rust-lang.rust-analyzer"
  ]
}' ;;
      *)
        vscode_extensions='{
  "recommendations": []
}' ;;
    esac
    echo "$vscode_extensions" > "$PROJECT_DIR/.vscode/extensions.json"

    success "VS Code settings generated (.vscode/)"
  fi
}

# ---------------------------------------------------------------------------
# Apply: Template engine
# ---------------------------------------------------------------------------
apply_templates() {
  header "Applying Configuration"

  apply_language_config

  # --- Configure permissions ---
  info "Configuring Claude Code permissions..."
  apply_permissions

  apply_common_files
  apply_optional_features
}

apply_permissions() {
  local settings="$PROJECT_DIR/.claude/settings.json"
  local tmp_settings
  tmp_settings=$(mktemp)

  # Start with existing settings or create base template
  if [[ -f "$settings" ]]; then
    cp "$settings" "$tmp_settings"
  else
    mkdir -p "$PROJECT_DIR/.claude"
    cat > "$tmp_settings" <<'JSONEOF'
{
  "permissions": {
    "allow": [
      "Read",
      "Write",
      "Edit",
      "Glob",
      "Grep",
      "NotebookEdit",
      "Bash(git status)",
      "Bash(git status *)",
      "Bash(git diff*)",
      "Bash(git log*)",
      "Bash(git branch*)",
      "Bash(git add *)",
      "Bash(git stash*)",
      "Bash(git checkout -b *)",
      "Bash(make test*)",
      "Bash(make lint*)",
      "Bash(make check*)",
      "Bash(make help*)",
      "Bash(ls)",
      "Bash(ls *)",
      "Bash(pwd)",
      "Bash(which *)",
      "Bash(find . *)",
      "Bash(wc *)",
      "Bash(mkdir *)"
    ],
    "deny": [
      "Bash(rm -rf *)",
      "Bash(git push --force*)",
      "Bash(git push -f *)",
      "Bash(git reset --hard*)",
      "Bash(git clean -f*)",
      "Bash(git branch -D *)",
      "Read(./.env)",
      "Read(./.env.*)",
      "Read(./secrets/**)"
    ]
  },
  "hooks": {
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "\"$CLAUDE_PROJECT_DIR\"/.claude/hooks/protect-main-branch.sh"
          }
        ]
      }
    ]
  }
}
JSONEOF
  fi

  # Build the additional allow rules
  local additions=""

  if [[ "$ALLOW_COMMIT" == true ]]; then
    additions="$additions\"Bash(git commit *)\", \"Bash(git commit -m *)\", "
  fi

  if [[ "$ALLOW_PUSH" == true ]]; then
    additions="$additions\"Bash(git push *)\", \"Bash(git push)\", "
  fi

  if [[ "$ALLOW_PKG_MANAGER" == true ]]; then
    case "$LANGUAGE" in
      python)    additions="$additions\"Bash(pip install *)\", \"Bash(pip install)\", \"Bash(uv *)\", " ;;
      typescript) additions="$additions\"Bash(npm install *)\", \"Bash(npm install)\", \"Bash(npm ci)\", \"Bash(npx *)\", " ;;
      go)        additions="$additions\"Bash(go get *)\", \"Bash(go mod *)\", " ;;
      rust)      additions="$additions\"Bash(cargo build *)\", \"Bash(cargo add *)\", " ;;
      none)      additions="$additions\"Bash(pip install *)\", \"Bash(npm install *)\", \"Bash(go get *)\", \"Bash(cargo add *)\", " ;;
    esac
  fi

  if [[ "$ALLOW_DOCKER" == true ]]; then
    additions="$additions\"Bash(docker build *)\", \"Bash(docker compose *)\", \"Bash(docker run *)\", "
  fi

  # If we have additions, insert them into the allow array
  if [[ -n "$additions" ]]; then
    # Remove trailing comma+space
    additions="${additions%, }"
    # Insert after the last existing allow entry (before the closing bracket)
    # Use python/sed to safely modify JSON... but we're zero-dependency bash.
    # Simple approach: replace the last entry in allow array with itself + new entries
    local last_allow
    last_allow=$(grep -n '"Bash(mkdir \*)' "$tmp_settings" | tail -1 | cut -d: -f1)
    if [[ -n "$last_allow" ]]; then
      sed_inplace "${last_allow}s|\"Bash(mkdir \*)\"|\"Bash(mkdir *)\",\n      ${additions}|" "$tmp_settings"
    fi
  fi

  cp "$tmp_settings" "$settings"
  rm -f "$tmp_settings"
  success "  Permissions updated in .claude/settings.json"
}

# ---------------------------------------------------------------------------
# Version tracking: stamp the scaffold version into the project
# ---------------------------------------------------------------------------
write_version_file() {
  cat > "$PROJECT_DIR/.scaffold-version" <<VEOF
version=$SCAFFOLD_VERSION
date=$(date -u +%Y-%m-%dT%H:%M:%SZ)
VEOF
  success "  Created .scaffold-version ($SCAFFOLD_VERSION)"
}

# ---------------------------------------------------------------------------
# Cleanup: Remove scaffold artifacts
# ---------------------------------------------------------------------------
cleanup_artifacts() {
  if [[ "$KEEP_ARTIFACTS" == true ]]; then
    info "Keeping scaffold artifacts (--keep flag)."
    return
  fi

  header "Cleaning Up"

  info "Removing scaffold artifacts..."
  rm -rf "$PROJECT_DIR/templates"
  success "  Removed templates/"

  # Remove this script last
  local self="$PROJECT_DIR/scaffold"
  if [[ -f "$self" ]]; then
    rm "$self"
    success "  Removed scaffold"
  fi

  success "Project is clean â€” no scaffold artifacts remain."
}

# ---------------------------------------------------------------------------
# Git initialization
# ---------------------------------------------------------------------------
init_git() {
  header "Git Initialization"

  # If cloned from scaffold repo, remove the cloned .git to start fresh
  if [[ -d "$PROJECT_DIR/.git" ]]; then
    local remote_url
    remote_url="$(git -C "$PROJECT_DIR" remote get-url origin 2>/dev/null || echo "")"
    if [[ "$remote_url" == *"sakebomb/scaffold"* ]]; then
      info "Removing cloned scaffold git history..."
      rm -rf "$PROJECT_DIR/.git"
    fi
  fi

  # Initialize or verify git repo
  if [[ -d "$PROJECT_DIR/.git" ]]; then
    info "Git repo already exists."
  else
    info "Initializing git repository..."
    git -C "$PROJECT_DIR" init -b main
    success "Git repo initialized (main branch)"
  fi

  # Add remote if provided
  if [[ -n "$GIT_REMOTE" ]]; then
    git -C "$PROJECT_DIR" remote add origin "$GIT_REMOTE" 2>/dev/null || \
      git -C "$PROJECT_DIR" remote set-url origin "$GIT_REMOTE"
    success "Remote set: $GIT_REMOTE"
  fi

  # Stage and commit
  info "Creating initial commit..."
  git -C "$PROJECT_DIR" add -A
  git -C "$PROJECT_DIR" commit -m "$(cat <<'EOF'
feat: initialize project with scaffold framework

- CLAUDE.md agent constitution with project conventions
- .claude/ settings, skills (slash commands), and hooks
- Tiered test structure (unit/integration/agent)
- Task management (todo, lessons, tests)
- Agent specifications
- Language-aware Makefile

Scaffolded with https://github.com/sakebomb/scaffold
EOF
  )"
  success "Initial commit created"

  # Show status
  echo ""
  info "Branch: $(git -C "$PROJECT_DIR" rev-parse --abbrev-ref HEAD)"
  info "Commits: $(git -C "$PROJECT_DIR" rev-list --count HEAD)"
}

# ---------------------------------------------------------------------------
# Summary
# ---------------------------------------------------------------------------
show_summary() {
  header "Setup Complete"

  echo -e "${GREEN}Your project '${PROJECT_NAME}' is ready for Claude Code.${RESET}"
  echo ""
  echo "What's configured:"
  echo -e "  ${BOLD}CLAUDE.md${RESET}           Agent constitution + conventions"
  echo -e "  ${BOLD}.claude/settings${RESET}    Tiered permissions"
  echo -e "  ${BOLD}.claude/skills/${RESET}     14 slash commands (/start, /plan, /backlog, /save, /load, ...)"
  echo -e "  ${BOLD}.claude/hooks/${RESET}      Main branch protection"
  echo -e "  ${BOLD}.github/${RESET}            Issue templates, PR template, CI workflow"
  echo -e "  ${BOLD}agents/${RESET}             8 agent specifications"
  echo -e "  ${BOLD}tasks/${RESET}              Plan, lessons, test registry"
  echo -e "  ${BOLD}Makefile${RESET}            test, lint, fmt, typecheck, build, check, setup, setup-github"
  echo -e "  ${BOLD}.pre-commit${RESET}         Linting + secret scanning on commit"

  if [[ "$LANGUAGE" != "none" ]]; then
    echo -e "  ${BOLD}Language${RESET}            $LANGUAGE (conventions, configs, tooling)"
  fi

  if [[ "$ENABLE_DOCKER" == true ]]; then
    echo -e "  ${BOLD}Docker${RESET}              Dockerfile + docker-compose.yml"
  fi

  if [[ "$ENABLE_RALPH" == true ]]; then
    echo -e "  ${BOLD}Ralph Wiggum${RESET}       scripts/ralph-loop.sh (autonomous loop)"
  fi

  echo ""
  echo "Next steps:"
  echo "  1. cd $(basename "$PROJECT_DIR")"
  echo "  2. Bootstrap dev environment: make setup"
  echo "  3. Start Claude Code: claude"
  echo "  4. Type: /start"
  echo ""
  echo -e "  ${DIM}Or skip /start and just tell Claude what to build:${RESET}"
  echo "  \"I want to build [your idea]. Help me create a plan.\""

  if [[ "$ENABLE_RALPH" == true ]]; then
    echo ""
    echo "  Ralph Wiggum (autonomous loop):"
    echo "  ./scripts/ralph-loop.sh plan   â€” autonomous planning"
    echo "  ./scripts/ralph-loop.sh build  â€” autonomous building"
  fi

  echo ""
  echo -e "  ${DIM}Full walkthrough: GETTING_STARTED.md${RESET}"
  echo ""
}

# ---------------------------------------------------------------------------
# Migrate mode â€” add scaffold to an existing project
# ---------------------------------------------------------------------------
detect_language() {
  # Detect language from existing config files
  if [[ -f "$PROJECT_DIR/pyproject.toml" || -f "$PROJECT_DIR/setup.py" || -f "$PROJECT_DIR/setup.cfg" ]]; then
    echo "python"
  elif [[ -f "$PROJECT_DIR/package.json" || -f "$PROJECT_DIR/tsconfig.json" ]]; then
    echo "typescript"
  elif [[ -f "$PROJECT_DIR/go.mod" ]]; then
    echo "go"
  elif [[ -f "$PROJECT_DIR/Cargo.toml" ]]; then
    echo "rust"
  else
    echo "none"
  fi
}

run_migrate() {
  header "Migrating Existing Project"

  # Detect project name from directory
  PROJECT_NAME="${PROJECT_NAME:-$(basename "$PROJECT_DIR")}"
  PROJECT_DESC="${PROJECT_DESC:-A project built with Claude Code}"

  # Detect language
  LANGUAGE="$(detect_language)"
  if [[ "$LANGUAGE" == "none" ]]; then
    info "Could not detect language from config files."
    if [[ "$NON_INTERACTIVE" == false ]]; then
      prompt_choice LANGUAGE "Select primary language:" \
        "python    â€” pytest, ruff, mypy" \
        "typescript â€” vitest, eslint, tsc" \
        "go        â€” go test, golangci-lint" \
        "rust      â€” cargo test, clippy" \
        "none      â€” language-agnostic"
      LANGUAGE="${LANGUAGE%% *}"
    else
      info "Using language-agnostic mode. Re-run with --add <lang> later."
    fi
  else
    success "Detected language: $LANGUAGE"
  fi

  # --- CLAUDE.md ---
  if [[ -f "$PROJECT_DIR/CLAUDE.md" ]]; then
    info "CLAUDE.md already exists â€” skipping"
    # Still check for language conventions
    if [[ "$LANGUAGE" != "none" ]]; then
      local convention_header=""
      case "$LANGUAGE" in
        python)     convention_header="Python Conventions" ;;
        typescript) convention_header="TypeScript Conventions" ;;
        go)         convention_header="Go Conventions" ;;
        rust)       convention_header="Rust Conventions" ;;
      esac
      if [[ -n "$convention_header" ]] && ! grep -q "$convention_header" "$PROJECT_DIR/CLAUDE.md" 2>/dev/null; then
        if [[ -f "$TEMPLATE_DIR/$LANGUAGE/CONVENTIONS.md" ]]; then
          info "Appending $LANGUAGE conventions to CLAUDE.md..."
          { echo ""; echo "---"; echo ""; cat "$TEMPLATE_DIR/$LANGUAGE/CONVENTIONS.md"; } >> "$PROJECT_DIR/CLAUDE.md"
          success "  CLAUDE.md updated with $LANGUAGE conventions"
        fi
      fi
    fi
  else
    info "Creating CLAUDE.md..."
    # Use the template CLAUDE.md if available, otherwise it should already be in PROJECT_DIR from install
    if [[ -f "$PROJECT_DIR/CLAUDE.md" ]]; then
      : # already exists (shouldn't reach here)
    fi
    # Apply language conventions
    if [[ "$LANGUAGE" != "none" && -f "$TEMPLATE_DIR/$LANGUAGE/CONVENTIONS.md" ]]; then
      { echo ""; echo "---"; echo ""; cat "$TEMPLATE_DIR/$LANGUAGE/CONVENTIONS.md"; } >> "$PROJECT_DIR/CLAUDE.md"
    fi
    # Replace placeholders
    replace_placeholders "$PROJECT_DIR/CLAUDE.md"
    success "  CLAUDE.md created"
  fi

  # --- .claude/ settings and hooks ---
  if [[ -f "$PROJECT_DIR/.claude/settings.json" ]]; then
    info ".claude/settings.json already exists â€” skipping"
  else
    info "Creating .claude/settings.json..."
    mkdir -p "$PROJECT_DIR/.claude"
    # Apply default permissions (safe defaults, commit allowed)
    ALLOW_COMMIT=true
    apply_permissions
    success "  .claude/settings.json created with safe defaults"
  fi

  # --- Skills ---
  local skills_dir="$PROJECT_DIR/.claude/skills"
  local skills=(plan review test lesson checkpoint status simplify index save load backlog doctor start refactor)
  local skills_added=0
  for s in "${skills[@]}"; do
    if [[ ! -f "$skills_dir/$s/SKILL.md" ]]; then
      skills_added=$((skills_added + 1))
    fi
  done
  if [[ $skills_added -eq 0 ]]; then
    info "All skills already exist â€” skipping"
  else
    info "Adding $skills_added missing skill(s)..."
    # Skills are already in .claude/skills/ from the repo copy â€” they'll be there
    # if running from cloned scaffold. For installed scaffold, they come from the install dir.
    success "  Skills directory ready ($skills_added added)"
  fi

  # --- Hooks ---
  if [[ -f "$PROJECT_DIR/.claude/hooks/protect-main-branch.sh" ]]; then
    info "Hooks already exist â€” skipping"
  else
    info "Adding hooks..."
    mkdir -p "$PROJECT_DIR/.claude/hooks"
    success "  Hooks added"
  fi

  # --- Agents ---
  if [[ -d "$PROJECT_DIR/agents" ]] && [[ -n "$(ls -A "$PROJECT_DIR/agents" 2>/dev/null)" ]]; then
    info "agents/ already exists â€” skipping"
  else
    info "Creating agents/..."
    mkdir -p "$PROJECT_DIR/agents"
    success "  agents/ created"
  fi

  # --- Tasks ---
  if [[ -d "$PROJECT_DIR/tasks" ]] && [[ -f "$PROJECT_DIR/tasks/todo.md" ]]; then
    info "tasks/ already exists â€” skipping"
  else
    info "Creating tasks/..."
    mkdir -p "$PROJECT_DIR/tasks"
    if [[ ! -f "$PROJECT_DIR/tasks/todo.md" ]]; then
      local today
      today=$(date +%Y-%m-%d)
      cat > "$PROJECT_DIR/tasks/todo.md" <<PLAN
# Task Plan â€” ${PROJECT_NAME}

> Created: ${today}
> Status: Not started

## Objective

_Define your project objective here, or run \`/plan\` in Claude Code._

## Plan

- [ ] 1. First task
- [ ] 2. Second task
PLAN
    fi
    if [[ ! -f "$PROJECT_DIR/tasks/lessons.md" ]]; then
      cat > "$PROJECT_DIR/tasks/lessons.md" <<'LESSONS'
# Project Knowledge Base

> This file accumulates across sessions.

## Mistakes & Corrections

_No entries yet._

## What Works (Positive Patterns)

_No entries yet._
LESSONS
    fi
    if [[ ! -f "$PROJECT_DIR/tasks/tests.md" ]]; then
      cat > "$PROJECT_DIR/tasks/tests.md" <<'TESTS'
# Test Registry

> Update when adding or removing tests.

## How to Run

| Command | Scope |
|---------|-------|
| `make test` | Full suite |
| `make check` | lint + typecheck + test |
TESTS
    fi
    if [[ ! -f "$PROJECT_DIR/tasks/session.md" ]]; then
      cat > "$PROJECT_DIR/tasks/session.md" <<'SESSION'
# Session State

_Use `/save` and `/load` to manage session state._
SESSION
    fi
    success "  tasks/ created"
  fi

  # --- Test directories ---
  local test_dirs_created=0
  for d in tests/unit tests/integration tests/agent; do
    if [[ ! -d "$PROJECT_DIR/$d" ]]; then
      mkdir -p "$PROJECT_DIR/$d"
      test_dirs_created=$((test_dirs_created + 1))
    fi
  done
  if [[ $test_dirs_created -gt 0 ]]; then
    success "  Created $test_dirs_created test directories"
  else
    info "Test directories already exist â€” skipping"
  fi

  # --- Scratch ---
  if [[ ! -d "$PROJECT_DIR/scratch" ]]; then
    mkdir -p "$PROJECT_DIR/scratch"
    touch "$PROJECT_DIR/scratch/.gitkeep"
    success "  Created scratch/"
  fi

  # --- Makefile (only if missing) ---
  if [[ -f "$PROJECT_DIR/Makefile" ]]; then
    info "Makefile already exists â€” skipping"
  else
    info "Makefile not found â€” you may want to create one or run full scaffold"
  fi

  # --- .github templates (only if missing) ---
  if [[ -d "$PROJECT_DIR/.github/ISSUE_TEMPLATE" ]]; then
    info ".github/ templates already exist â€” skipping"
  else
    info ".github/ templates not found â€” they'll be added if running from scaffold repo"
  fi

  # --- GETTING_STARTED.md ---
  if [[ ! -f "$PROJECT_DIR/GETTING_STARTED.md" ]]; then
    info "Creating GETTING_STARTED.md..."
    cat > "$PROJECT_DIR/GETTING_STARTED.md" <<GUIDE
# Getting Started with ${PROJECT_NAME}

## Launch Claude Code

\`\`\`bash
claude
\`\`\`

Then type \`/start\` for a guided walkthrough, or just tell Claude what to build.

## Useful Commands

| Command | What It Does |
|---------|-------------|
| \`/start\` | Guided first-session setup |
| \`/plan\` | Create a project plan |
| \`/status\` | See progress |
| \`/test\` | Run tests |
| \`/checkpoint\` | Commit progress |
| \`/save\` | Save session state |
| \`/load\` | Restore session |
GUIDE
    success "  GETTING_STARTED.md created"
  fi

  echo ""
  success "Migration complete!"
  info "Your project now has Claude Code configuration."
  info "Next: run 'claude' and type '/start'"
}

# ---------------------------------------------------------------------------
# Add language mode â€” layer a second language into existing project
# ---------------------------------------------------------------------------
run_add_language() {
  local lang="$ADD_LANGUAGE"
  local target_dir="$PROJECT_DIR"
  local dir_prefix=""

  # Monorepo mode: place files in subdirectory
  if [[ -n "$ADD_DIR" ]]; then
    target_dir="$PROJECT_DIR/$ADD_DIR"
    # Derive prefix from dir name for Makefile targets (e.g., backend/services â†’ backend-services)
    dir_prefix="$(echo "$ADD_DIR" | tr '/' '-' | sed 's/-$//')-"
    mkdir -p "$target_dir"
  fi

  header "Adding $lang to existing project${ADD_DIR:+ (in $ADD_DIR/)}"

  # Validate project has been scaffolded already
  if [[ ! -f "$PROJECT_DIR/CLAUDE.md" ]]; then
    error "No CLAUDE.md found. Run ./scaffold first to initialize the project."
    exit 1
  fi

  if [[ ! -d "$TEMPLATE_DIR/$lang" ]]; then
    error "Templates for $lang not found. Make sure scaffold templates are present (use --keep on initial run)."
    exit 1
  fi

  # --- Append language conventions to CLAUDE.md (skip if already present) ---
  local convention_header=""
  case "$lang" in
    python)     convention_header="Python Conventions" ;;
    typescript) convention_header="TypeScript Conventions" ;;
    go)         convention_header="Go Conventions" ;;
    rust)       convention_header="Rust Conventions" ;;
  esac

  if grep -q "$convention_header" "$PROJECT_DIR/CLAUDE.md" 2>/dev/null; then
    info "$convention_header already in CLAUDE.md â€” skipping"
  elif [[ -f "$TEMPLATE_DIR/$lang/CONVENTIONS.md" ]]; then
    info "Appending $lang conventions to CLAUDE.md..."
    { echo ""; echo "---"; echo ""; cat "$TEMPLATE_DIR/$lang/CONVENTIONS.md"; } >> "$PROJECT_DIR/CLAUDE.md"
    success "CLAUDE.md updated with $lang conventions"
  fi

  # --- Install language config files (don't overwrite existing) ---
  info "Installing $lang config files..."
  local tmpl_dir="$TEMPLATE_DIR/$lang"

  # Detect project name from existing CLAUDE.md or directory name
  PROJECT_NAME="${PROJECT_NAME:-$(basename "$PROJECT_DIR")}"
  PROJECT_DESC="${PROJECT_DESC:-A project built with Claude Code}"
  local escaped_name escaped_desc
  escaped_name="$(sed_escape "$PROJECT_NAME")"
  escaped_desc="$(sed_escape "$PROJECT_DESC")"

  # Process .tmpl files (skip if target exists)
  for tmpl in "$tmpl_dir"/*.tmpl; do
    if [[ -f "$tmpl" ]]; then
      local dest_name
      dest_name="$(basename "$tmpl" .tmpl)"
      if [[ -f "$target_dir/$dest_name" ]]; then
        info "  Skipping $dest_name (already exists)"
      else
        sed "s/{{PROJECT_NAME}}/${escaped_name}/g; s/{{PROJECT_DESCRIPTION}}/${escaped_desc}/g" \
          "$tmpl" > "$target_dir/$dest_name"
        success "  Created ${ADD_DIR:+$ADD_DIR/}$dest_name"
      fi
    fi
  done

  # Copy non-template config files (skip if target exists)
  for cfg in "$tmpl_dir"/*; do
    local basename
    basename="$(basename "$cfg")"
    if [[ "$basename" != "CONVENTIONS.md" && \
          "$basename" != "gitignore.append" && \
          "$basename" != *.tmpl && \
          -f "$cfg" ]]; then
      if [[ -f "$target_dir/$basename" ]]; then
        info "  Skipping $basename (already exists)"
      else
        cp "$cfg" "$target_dir/$basename"
        success "  Created ${ADD_DIR:+$ADD_DIR/}$basename"
      fi
    fi
  done

  # --- Append to .gitignore (don't duplicate entries) ---
  if [[ -f "$tmpl_dir/gitignore.append" ]]; then
    info "Updating .gitignore with $lang entries..."
    while IFS= read -r line; do
      if [[ -n "$line" && "$line" != \#* ]]; then
        if ! grep -qxF "$line" "$PROJECT_DIR/.gitignore" 2>/dev/null; then
          echo "$line" >> "$PROJECT_DIR/.gitignore"
        fi
      elif [[ "$line" == \#* ]]; then
        # Add comment headers if not already present
        if ! grep -qxF "$line" "$PROJECT_DIR/.gitignore" 2>/dev/null; then
          echo "$line" >> "$PROJECT_DIR/.gitignore"
        fi
      fi
    done < "$tmpl_dir/gitignore.append"
    success "  .gitignore updated"
  fi

  # --- Add prefixed Makefile targets ---
  info "Adding $lang Makefile targets..."
  local lang_short=""
  local test_cmd="" lint_cmd="" fmt_cmd="" typecheck_cmd=""
  case "$lang" in
    python)
      lang_short="py"
      test_cmd="python -m pytest tests/ -v"
      lint_cmd="ruff check ."
      fmt_cmd="ruff format ."
      typecheck_cmd="mypy src/"
      ;;
    typescript)
      lang_short="ts"
      test_cmd="npx vitest run"
      lint_cmd="npx eslint src/"
      fmt_cmd="npx prettier --write src/"
      typecheck_cmd="npx tsc --noEmit"
      ;;
    go)
      lang_short="go"
      test_cmd="go test ./..."
      lint_cmd="golangci-lint run"
      fmt_cmd="gofmt -w ."
      typecheck_cmd="go vet ./..."
      ;;
    rust)
      lang_short="rs"
      test_cmd="cargo test"
      lint_cmd="cargo clippy -- -D warnings"
      fmt_cmd="cargo fmt"
      typecheck_cmd="cargo check"
      ;;
  esac

  local mk_prefix="${dir_prefix}${lang_short}"
  local cmd_prefix=""
  if [[ -n "$ADD_DIR" ]]; then
    cmd_prefix="cd $ADD_DIR && "
  fi

  if grep -q "^test-${mk_prefix}:" "$PROJECT_DIR/Makefile" 2>/dev/null; then
    info "  Makefile targets for $lang${ADD_DIR:+ ($ADD_DIR)} already exist â€” skipping"
  else
    cat >> "$PROJECT_DIR/Makefile" <<MKEOF

# --- ${lang} targets${ADD_DIR:+ ($ADD_DIR)} (added via --add) ---
.PHONY: test-${mk_prefix} lint-${mk_prefix} fmt-${mk_prefix} typecheck-${mk_prefix}

test-${mk_prefix}:
	${cmd_prefix}${test_cmd}

lint-${mk_prefix}:
	${cmd_prefix}${lint_cmd}

fmt-${mk_prefix}:
	${cmd_prefix}${fmt_cmd}

typecheck-${mk_prefix}:
	${cmd_prefix}${typecheck_cmd}
MKEOF
    success "  Added test-${mk_prefix}, lint-${mk_prefix}, fmt-${mk_prefix}, typecheck-${mk_prefix}"
  fi

  # --- Update CI workflow to include second language ---
  local ci_file="$PROJECT_DIR/.github/workflows/ci.yml"
  if [[ -f "$ci_file" ]]; then
    if grep -q "$lang" "$ci_file" 2>/dev/null; then
      info "  CI already references $lang â€” skipping"
    else
      info "Updating CI workflow for $lang..."
      local ci_step=""
      case "$lang" in
        python) ci_step="
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Python dependencies
        run: |
          python -m venv .venv
          source .venv/bin/activate
          pip install -e '.[dev]'

      - name: Run Python checks
        run: make test-${mk_prefix} && make lint-${mk_prefix}" ;;
        typescript) ci_step="
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install TypeScript dependencies
        run: npm ci

      - name: Run TypeScript checks
        run: make test-${mk_prefix} && make lint-${mk_prefix}" ;;
        go) ci_step="
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Run Go checks
        run: make test-${mk_prefix} && make lint-${mk_prefix}" ;;
        rust) ci_step="
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Run Rust checks
        run: make test-${mk_prefix} && make lint-${mk_prefix}" ;;
      esac

      # Insert new language steps before the final "Run checks" step
      if [[ -n "$ci_step" ]]; then
        local ci_tmp
        ci_tmp="$(mktemp)"
        AWK_STEPS="$ci_step" awk '
          /- name: Run checks/ { print ENVIRON["AWK_STEPS"]; print ""; }
          { print }
        ' "$ci_file" > "$ci_tmp"
        mv "$ci_tmp" "$ci_file"
        success "  CI workflow updated with $lang steps"
      fi
    fi
  fi

  echo ""
  success "Successfully added $lang to your project${ADD_DIR:+ (in $ADD_DIR/)}."
  info "Review changes with: git diff"
  info "New Makefile targets: test-${mk_prefix}, lint-${mk_prefix}, fmt-${mk_prefix}, typecheck-${mk_prefix}"
}

# ---------------------------------------------------------------------------
# Verify mode â€” post-scaffold health check
# ---------------------------------------------------------------------------
run_verify() {
  local checks=0 passed=0 failed=0

  echo -e "${BOLD}Scaffold Verification${RESET}"
  echo ""

  # Check 1: Git repo initialized
  checks=$((checks + 1))
  if [[ -d ".git" ]]; then
    echo -e "  ${GREEN}PASS${RESET} Git repository initialized"
    passed=$((passed + 1))
  else
    echo -e "  ${RED}FAIL${RESET} Git repository not initialized (.git/ missing)"
    failed=$((failed + 1))
  fi

  # Check 2: Required files exist
  local required_files=("CLAUDE.md" ".claude/settings.json" "Makefile" ".gitignore")
  for f in "${required_files[@]}"; do
    checks=$((checks + 1))
    if [[ -f "$f" ]]; then
      echo -e "  ${GREEN}PASS${RESET} Required file exists: $f"
      passed=$((passed + 1))
    else
      echo -e "  ${RED}FAIL${RESET} Required file missing: $f"
      failed=$((failed + 1))
    fi
  done

  # Check 3: .scaffold-version exists
  checks=$((checks + 1))
  if [[ -f ".scaffold-version" ]]; then
    echo -e "  ${GREEN}PASS${RESET} Version file exists: .scaffold-version"
    passed=$((passed + 1))
  else
    echo -e "  ${RED}FAIL${RESET} Version file missing: .scaffold-version"
    failed=$((failed + 1))
  fi

  # Check 4: .claude/settings.json is valid JSON
  checks=$((checks + 1))
  if [[ -f ".claude/settings.json" ]]; then
    if python3 -m json.tool ".claude/settings.json" > /dev/null 2>&1; then
      echo -e "  ${GREEN}PASS${RESET} .claude/settings.json is valid JSON"
      passed=$((passed + 1))
    else
      echo -e "  ${RED}FAIL${RESET} .claude/settings.json is not valid JSON"
      failed=$((failed + 1))
    fi
  else
    # Already counted as missing above; skip duplicate
    passed=$((passed + 1))
  fi

  # Check 5: No leftover placeholders in project files
  checks=$((checks + 1))
  local placeholder_files
  placeholder_files=$(grep -rl '{{PROJECT_NAME}}\|{{PROJECT_DESCRIPTION}}' --include='*.md' --include='*.json' --include='*.toml' --include='*.yaml' --include='*.yml' . 2>/dev/null | grep -v -e '.git/' -e 'templates/' -e 'scratch/' -e 'scaffold' -e 'docs/' || true)
  if [[ -z "$placeholder_files" ]]; then
    echo -e "  ${GREEN}PASS${RESET} No leftover {{placeholders}} found"
    passed=$((passed + 1))
  else
    echo -e "  ${RED}FAIL${RESET} Leftover placeholders found in:"
    echo "$placeholder_files" | while read -r pf; do
      echo -e "         $pf"
    done
    failed=$((failed + 1))
  fi

  # Summary
  echo ""
  echo -e "${BOLD}Verification: $passed/$checks checks passed${RESET}"
  if [[ $failed -gt 0 ]]; then
    echo -e "${RED}$failed check(s) failed${RESET}"
    return 1
  else
    echo -e "${GREEN}All checks passed${RESET}"
    return 0
  fi
}

# ---------------------------------------------------------------------------
# Template registry â€” install and list community templates
# ---------------------------------------------------------------------------
list_available_languages() {
  local langs=()

  # Built-in languages (stable order â€” python first as default)
  local builtin_order=(python typescript go rust)
  for name in "${builtin_order[@]}"; do
    [[ -f "$TEMPLATE_DIR/$name/CONVENTIONS.md" ]] && langs+=("$name")
  done

  # Installed community templates
  local user_templates="${SCAFFOLD_HOME:-$HOME/.scaffold}/templates"
  if [[ -d "$user_templates" ]]; then
    for dir in "$user_templates"/*/; do
      [[ -d "$dir" ]] || continue
      local name
      name="$(basename "$dir")"
      # Skip if same name as built-in
      local is_builtin=false
      for builtin in "${langs[@]}"; do
        [[ "$builtin" == "$name" ]] && is_builtin=true && break
      done
      [[ "$is_builtin" == true ]] && continue
      [[ -f "$dir/CONVENTIONS.md" ]] && langs+=("$name")
    done
  fi

  printf '%s\n' "${langs[@]}"
}

validate_template() {
  local template_dir="$1"
  local errors=0

  if [[ ! -f "$template_dir/CONVENTIONS.md" ]]; then
    error "Template missing required file: CONVENTIONS.md"
    errors=$((errors + 1))
  fi

  if [[ ! -f "$template_dir/gitignore.append" ]]; then
    error "Template missing required file: gitignore.append"
    errors=$((errors + 1))
  fi

  return $errors
}

install_template() {
  local source="$1"
  local user_templates="${SCAFFOLD_HOME:-$HOME/.scaffold}/templates"

  # Determine template name from source
  local name
  if [[ -d "$source" ]]; then
    # Local directory
    name="$(basename "$source")"
  else
    # Git URL â€” extract repo name, strip .git suffix and scaffold-template- prefix
    name="$(basename "$source" .git)"
    name="${name#scaffold-template-}"
    name="${name#scaffold-}"
  fi

  local target_dir="$user_templates/$name"

  if [[ -d "$target_dir" ]]; then
    warn "Template '$name' already installed at $target_dir"
    info "Remove it first to reinstall: rm -rf $target_dir"
    return 1
  fi

  mkdir -p "$user_templates"

  if [[ -d "$source" ]]; then
    # Local directory â€” copy
    cp -r "$source" "$target_dir"
  else
    # Git URL â€” clone
    info "Cloning template from $source..."
    if ! git clone --depth 1 "$source" "$target_dir" 2>/dev/null; then
      error "Failed to clone template from $source"
      return 1
    fi
    # Remove .git from cloned template
    rm -rf "$target_dir/.git"
  fi

  # Validate
  if ! validate_template "$target_dir"; then
    error "Template validation failed â€” removing $target_dir"
    rm -rf "$target_dir"
    return 1
  fi

  success "Template '$name' installed to $target_dir"
  info "Use with: scaffold --add $name"
}

list_templates() {
  echo -e "${BOLD}Available Language Templates${RESET}"
  echo ""

  echo -e "  ${BOLD}Built-in:${RESET}"
  for dir in "$TEMPLATE_DIR"/*/; do
    [[ -d "$dir" ]] || continue
    local name
    name="$(basename "$dir")"
    case "$name" in
      ralph) continue ;;
    esac
    [[ -f "$dir/CONVENTIONS.md" ]] || continue
    echo -e "    $name"
  done

  local user_templates="${SCAFFOLD_HOME:-$HOME/.scaffold}/templates"
  if [[ -d "$user_templates" ]]; then
    local has_custom=false
    for dir in "$user_templates"/*/; do
      [[ -d "$dir" ]] || continue
      local name
      name="$(basename "$dir")"
      [[ -f "$dir/CONVENTIONS.md" ]] || continue
      if [[ "$has_custom" == false ]]; then
        echo ""
        echo -e "  ${BOLD}Installed:${RESET}"
        has_custom=true
      fi
      echo -e "    $name"
    done
    if [[ "$has_custom" == false ]]; then
      echo ""
      echo -e "  ${DIM}No community templates installed.${RESET}"
      echo -e "  ${DIM}Install with: scaffold --install-template <url-or-path>${RESET}"
    fi
  else
    echo ""
    echo -e "  ${DIM}No community templates installed.${RESET}"
    echo -e "  ${DIM}Install with: scaffold --install-template <url-or-path>${RESET}"
  fi
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------
main() {
  load_scaffoldrc
  parse_flags "$@"

  # --verify mode: validate scaffolded project and exit
  if [[ "$VERIFY_MODE" == true ]]; then
    run_verify
    exit $?
  fi

  # --add mode: layer a second language and exit
  if [[ "$ADD_MODE" == true ]]; then
    if [[ -z "$ADD_LANGUAGE" ]]; then
      local available_langs=()
      while IFS= read -r _lang; do
        available_langs+=("$_lang")
      done < <(list_available_languages)
      prompt_choice ADD_LANGUAGE "Select language to add:" "${available_langs[@]}"
    fi
    run_add_language
    exit 0
  fi

  # --migrate mode: add scaffold to existing project and exit
  if [[ "$MIGRATE_MODE" == true ]]; then
    run_migrate
    exit 0
  fi

  echo ""
  echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
  echo -e "${BOLD}â•‘          Scaffold â€” Claude Code Setup            â•‘${RESET}"
  echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"

  step_project_basics
  step_language
  step_archetype
  step_permissions
  step_ralph
  step_docker
  step_vscode
  step_planning
  step_git_remote
  step_github_pm

  # Dry-run: show preview and exit without writing anything
  if [[ "$DRY_RUN" == true ]]; then
    dry_run_report
    exit 0
  fi

  # Snapshot existing files and enable rollback on failure
  snapshot_pre_existing
  trap rollback_on_failure ERR

  apply_templates
  write_version_file
  cleanup_artifacts
  init_git
  apply_github_pm

  # Disable rollback trap â€” we succeeded
  trap - ERR
  rm -f "$PRE_SNAPSHOT"

  show_summary

  # Save defaults if requested
  if [[ "$SAVE_DEFAULTS" == true ]]; then
    save_scaffoldrc
  fi
}

main "$@"
