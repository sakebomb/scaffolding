#!/usr/bin/env bash
# =============================================================================
# scaffold â€” Project initializer for Claude Code
# =============================================================================
# Sets up a project optimized for Claude Code with:
#   - CLAUDE.md agent constitution + language-specific conventions
#   - .claude/ settings, skills (slash commands), and hooks
#   - Tiered test structure + Makefile
#   - Task management (todo, lessons, tests)
#   - Agent specifications
#   - Optional Ralph Wiggum autonomous loop
#
# Usage:
#   ./scaffold                  Interactive setup
#   ./scaffold --help           Show help
#   ./scaffold --keep           Don't remove scaffold artifacts after init
#   ./scaffold --non-interactive Use defaults for all prompts
#   ./scaffold --dry-run        Preview what would be created
#   ./scaffold --completions    Output bash completion script
#   ./scaffold --add <lang>     Layer a second language into existing project
# =============================================================================
set -eEuo pipefail

# ---------------------------------------------------------------------------
# Globals
# ---------------------------------------------------------------------------
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
KEEP_ARTIFACTS=false
NON_INTERACTIVE=false
DRY_RUN=false
PROJECT_NAME=""
PROJECT_DESC=""
LANGUAGE=""
ENABLE_RALPH=false
GIT_REMOTE=""
ALLOW_COMMIT=false
ALLOW_PUSH=false
ALLOW_PKG_MANAGER=false
ALLOW_DOCKER=false
SETUP_LABELS=false
SETUP_KANBAN=false
ENABLE_DOCKER=false
ENABLE_VSCODE=false
ARCHETYPE="none"
ADD_LANGUAGE=""

# Rollback tracking
PRE_SNAPSHOT=""

# Colors (disabled if not a terminal)
if [[ -t 1 ]]; then
  BOLD='\033[1m'
  DIM='\033[2m'
  GREEN='\033[0;32m'
  YELLOW='\033[0;33m'
  CYAN='\033[0;36m'
  RED='\033[0;31m'
  RESET='\033[0m'
else
  BOLD='' DIM='' GREEN='' YELLOW='' CYAN='' RED='' RESET=''
fi

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------
info()    { echo -e "${CYAN}â–¸${RESET} $*"; }
success() { echo -e "${GREEN}âœ“${RESET} $*"; }
warn()    { echo -e "${YELLOW}âš ${RESET} $*"; }
error()   { echo -e "${RED}âœ—${RESET} $*" >&2; }
header()  { echo -e "\n${BOLD}â•â•â• $* â•â•â•${RESET}\n"; }

# Snapshot all files that exist before scaffold modifies anything
snapshot_pre_existing() {
  PRE_SNAPSHOT="$(mktemp)"
  find "$SCRIPT_DIR" -not -path "$SCRIPT_DIR/.git/*" -not -name '.git' | sort > "$PRE_SNAPSHOT"
}

# Rollback handler â€” called on ERR if trap is set
rollback_on_failure() {
  local exit_code=$?
  echo ""
  error "Scaffold failed (exit code: $exit_code)"
  echo ""

  # Find files created since snapshot
  local post_snapshot
  post_snapshot="$(mktemp)"
  find "$SCRIPT_DIR" -not -path "$SCRIPT_DIR/.git/*" -not -name '.git' | sort > "$post_snapshot"
  local new_files
  new_files="$(comm -13 "$PRE_SNAPSHOT" "$post_snapshot" || true)"
  rm -f "$post_snapshot"

  if [[ -z "$new_files" ]]; then
    warn "No new files were created before the failure."
    rm -f "$PRE_SNAPSHOT"
    exit "$exit_code"
  fi

  warn "The following files were created before the failure:"
  echo "$new_files" | while IFS= read -r f; do
    echo "  ${f#"$SCRIPT_DIR"/}"
  done
  echo ""

  if [[ "$NON_INTERACTIVE" == true ]]; then
    warn "Non-interactive mode: cleaning up created files automatically."
    perform_rollback "$new_files"
    rm -f "$PRE_SNAPSHOT"
    exit "$exit_code"
  fi

  local answer="n"
  read -rp "Roll back created files? [y/N]: " answer
  if [[ "${answer,,}" == "y" || "${answer,,}" == "yes" ]]; then
    perform_rollback "$new_files"
  else
    warn "Partial files left in place. Review manually."
  fi
  rm -f "$PRE_SNAPSHOT"
  exit "$exit_code"
}

# Remove files created during the run, deepest first
perform_rollback() {
  local new_files="$1"
  local removed=0
  # Sort in reverse so deeper paths are removed first
  echo "$new_files" | sort -r | while IFS= read -r f; do
    if [[ -f "$f" ]]; then
      rm -f "$f"
      removed=$((removed + 1))
    elif [[ -d "$f" ]] && [[ -z "$(ls -A "$f" 2>/dev/null)" ]]; then
      rmdir "$f" 2>/dev/null || true
      removed=$((removed + 1))
    fi
  done
  success "Rolled back created files."
}

# Escape string for use as sed replacement (handles /, &, \, newlines)
sed_escape() {
  printf '%s' "$1" | sed -e 's/[\/&\\]/\\&/g'
}

prompt() {
  local var_name="$1" prompt_text="$2" default="$3"
  if [[ "$NON_INTERACTIVE" == true ]]; then
    printf -v "$var_name" '%s' "$default"
    return
  fi
  local display_default=""
  if [[ -n "$default" ]]; then
    display_default=" ${DIM}[$default]${RESET}"
  fi
  echo -ne "${CYAN}?${RESET} ${prompt_text}${display_default}: "
  local input
  read -r input
  if [[ -z "$input" ]]; then
    printf -v "$var_name" '%s' "$default"
  else
    printf -v "$var_name" '%s' "$input"
  fi
}

prompt_yn() {
  local var_name="$1" prompt_text="$2" default="$3"
  if [[ "$NON_INTERACTIVE" == true ]]; then
    printf -v "$var_name" '%s' "$default"
    return
  fi
  local yn_hint="y/n"
  if [[ "$default" == true ]]; then yn_hint="Y/n"; fi
  if [[ "$default" == false ]]; then yn_hint="y/N"; fi
  echo -ne "${CYAN}?${RESET} ${prompt_text} ${DIM}[$yn_hint]${RESET}: "
  local input
  read -r input
  case "${input,,}" in
    y|yes) printf -v "$var_name" '%s' "true" ;;
    n|no)  printf -v "$var_name" '%s' "false" ;;
    *)     printf -v "$var_name" '%s' "$default" ;;
  esac
}

prompt_choice() {
  local var_name="$1" prompt_text="$2"
  shift 2
  local options=("$@")

  if [[ "$NON_INTERACTIVE" == true ]]; then
    printf -v "$var_name" '%s' "${options[0]}"
    return
  fi

  echo -e "${CYAN}?${RESET} ${prompt_text}"
  local i=1
  for opt in "${options[@]}"; do
    echo -e "  ${BOLD}$i)${RESET} $opt"
    i=$((i + 1))
  done
  echo -ne "${DIM}  Enter number [1]: ${RESET}"
  local input
  read -r input
  if [[ -z "$input" || "$input" -lt 1 || "$input" -gt ${#options[@]} ]] 2>/dev/null; then
    printf -v "$var_name" '%s' "${options[0]}"
  else
    printf -v "$var_name" '%s' "${options[$((input - 1))]}"
  fi
}

# ---------------------------------------------------------------------------
# Parse CLI flags
# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
# Update mode â€” pull latest skills, agents, hooks from scaffold repo
# ---------------------------------------------------------------------------
SCAFFOLD_REPO="https://raw.githubusercontent.com/sakebomb/scaffold/main"

run_update() {
  header "Scaffold Update"

  info "Checking for updates from scaffold repo..."
  echo ""

  if ! command -v curl &>/dev/null; then
    error "curl is required for updates. Install it and try again."
    exit 1
  fi

  # Directories to update
  local update_dirs=(".claude/skills" ".claude/hooks" "agents")
  local update_files=()
  local changed=0

  # Discover files to update
  for dir in "${update_dirs[@]}"; do
    if [[ ! -d "$SCRIPT_DIR/$dir" ]]; then
      info "Skipping $dir (directory not found)"
      continue
    fi
    while IFS= read -r -d '' file; do
      local rel_path="${file#"$SCRIPT_DIR"/}"
      update_files+=("$rel_path")
    done < <(find "$SCRIPT_DIR/$dir" -type f -name "*.md" -o -name "*.sh" -o -name "*.json" -print0 2>/dev/null | sort -z)
  done

  # Check each file for changes
  local tmp_dir
  tmp_dir="$(mktemp -d)"
  trap 'rm -rf "$tmp_dir"' EXIT

  for rel_path in "${update_files[@]}"; do
    local url="$SCAFFOLD_REPO/$rel_path"
    local tmp_file="$tmp_dir/$rel_path"
    mkdir -p "$(dirname "$tmp_file")"

    if curl -sf "$url" -o "$tmp_file" 2>/dev/null; then
      if [[ -f "$SCRIPT_DIR/$rel_path" ]]; then
        if ! diff -q "$SCRIPT_DIR/$rel_path" "$tmp_file" &>/dev/null; then
          changed=$((changed + 1))
          echo -e "  ${YELLOW}Changed:${RESET} $rel_path"
        fi
      else
        changed=$((changed + 1))
        echo -e "  ${GREEN}New:${RESET} $rel_path"
      fi
    fi
  done

  if [[ $changed -eq 0 ]]; then
    success "Everything is up to date."
    exit 0
  fi

  echo ""
  info "$changed file(s) have updates available."
  echo ""

  # Show diffs
  for rel_path in "${update_files[@]}"; do
    local tmp_file="$tmp_dir/$rel_path"
    if [[ -f "$tmp_file" && -f "$SCRIPT_DIR/$rel_path" ]]; then
      if ! diff -q "$SCRIPT_DIR/$rel_path" "$tmp_file" &>/dev/null; then
        echo -e "\n${BOLD}--- $rel_path ---${RESET}"
        diff --color=auto -u "$SCRIPT_DIR/$rel_path" "$tmp_file" || true
      fi
    fi
  done

  echo ""
  local apply="n"
  read -rp "Apply these updates? [y/N]: " apply
  if [[ "$apply" != "y" && "$apply" != "Y" ]]; then
    info "Update cancelled."
    exit 0
  fi

  # Apply updates
  for rel_path in "${update_files[@]}"; do
    local tmp_file="$tmp_dir/$rel_path"
    if [[ -f "$tmp_file" ]]; then
      if [[ ! -f "$SCRIPT_DIR/$rel_path" ]] || ! diff -q "$SCRIPT_DIR/$rel_path" "$tmp_file" &>/dev/null; then
        mkdir -p "$(dirname "$SCRIPT_DIR/$rel_path")"
        cp "$tmp_file" "$SCRIPT_DIR/$rel_path"
      fi
    fi
  done

  success "Updated $changed file(s)."
  info "Review changes with: git diff"
}

# ---------------------------------------------------------------------------
# Shell completions
# ---------------------------------------------------------------------------
print_completions() {
  cat <<'COMP'
# Bash completion for scaffold
# Enable: source <(./scaffold --completions)
# Persist: ./scaffold --completions >> ~/.bashrc

_scaffold_completions() {
  local cur="${COMP_WORDS[COMP_CWORD]}"
  local prev="${COMP_WORDS[COMP_CWORD-1]}"

  # Complete language after --add
  if [[ "$prev" == "--add" ]]; then
    COMPREPLY=($(compgen -W "python typescript go rust" -- "$cur"))
    return
  fi

  # Complete flags
  local flags="--help --keep --non-interactive --dry-run --update --completions --add"
  COMPREPLY=($(compgen -W "$flags" -- "$cur"))
}

complete -F _scaffold_completions ./scaffold
complete -F _scaffold_completions scaffold
COMP
}

parse_flags() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --help|-h)
        show_help
        exit 0
        ;;
      --keep)
        KEEP_ARTIFACTS=true
        shift
        ;;
      --non-interactive)
        NON_INTERACTIVE=true
        shift
        ;;
      --dry-run)
        DRY_RUN=true
        shift
        ;;
      --update)
        run_update
        exit 0
        ;;
      --completions)
        print_completions
        exit 0
        ;;
      --add)
        if [[ -z "${2:-}" ]]; then
          error "--add requires a language argument (python, typescript, go, rust)"
          exit 1
        fi
        case "$2" in
          python|typescript|go|rust) ADD_LANGUAGE="$2" ;;
          *) error "Unsupported language: $2 (choose: python, typescript, go, rust)"; exit 1 ;;
        esac
        shift 2
        ;;
      *)
        error "Unknown flag: $1"
        echo "Run './scaffold --help' for usage."
        exit 1
        ;;
    esac
  done
}

show_help() {
  cat <<'HELP'
scaffold â€” Project initializer for Claude Code

Usage:
  ./scaffold [OPTIONS]

Options:
  --help, -h          Show this help message
  --keep              Don't remove scaffold artifacts after init
  --non-interactive   Use defaults for all prompts (for CI/automation)
  --dry-run           Preview what would be created without writing anything
  --update            Update skills, agents, and hooks from scaffold repo
  --completions       Output bash completion script
  --add <lang>        Layer a second language into an existing project
                      Supported: python, typescript, go, rust

What it does:
  1. Asks for project name, description, language, and archetype
  2. Configures Claude Code permissions based on your preferences
  3. Sets up language-specific tooling (linter, formatter, test runner)
  4. Generates archetype structure (CLI, API, or library starter files)
  5. Optionally integrates Ralph Wiggum autonomous loop
  5. Helps you create or load a project plan
  6. Initializes git with a clean first commit
  7. Removes scaffold artifacts (unless --keep is used)

After running, your project is ready for Claude Code from session one.

Non-interactive defaults:
  Project name:    directory name
  Language:        python
  Permissions:     safe defaults only
  Ralph Wiggum:    disabled
  Project plan:    template only
HELP
}

# ---------------------------------------------------------------------------
# Dry-run report â€” show what would be created without writing anything
# ---------------------------------------------------------------------------
dry_run_report() {
  echo ""
  header "Dry Run Preview"
  echo ""
  echo -e "  ${BOLD}Project:${RESET}     $PROJECT_NAME"
  echo -e "  ${BOLD}Description:${RESET} $PROJECT_DESC"
  echo -e "  ${BOLD}Language:${RESET}    $LANGUAGE"
  echo -e "  ${BOLD}Archetype:${RESET}  $ARCHETYPE"
  echo -e "  ${BOLD}Docker:${RESET}      $ENABLE_DOCKER"
  echo -e "  ${BOLD}VS Code:${RESET}    $ENABLE_VSCODE"
  echo -e "  ${BOLD}Ralph:${RESET}       $ENABLE_RALPH"
  echo ""
  echo -e "${BOLD}Files that would be created:${RESET}"
  echo ""

  # Common files (always created)
  echo "  CLAUDE.md"
  echo "  README.md"
  echo "  GETTING_STARTED.md"
  echo "  LICENSE"
  echo "  Makefile"
  echo "  .gitignore"
  echo "  .env.example"
  echo "  CHANGELOG.md"
  echo "  SECURITY.md"
  echo "  .pre-commit-config.yaml"
  echo "  .claude/settings.json"
  echo "  .claude/hooks/protect-main-branch.sh"

  # Skills
  local skills=(plan review test lesson checkpoint status simplify index save load backlog doctor start)
  for s in "${skills[@]}"; do
    echo "  .claude/skills/$s/SKILL.md"
  done

  # GitHub
  echo "  .github/ISSUE_TEMPLATE/bug.yml"
  echo "  .github/ISSUE_TEMPLATE/feature.yml"
  echo "  .github/ISSUE_TEMPLATE/task.yml"
  echo "  .github/ISSUE_TEMPLATE/config.yml"
  echo "  .github/pull_request_template.md"
  echo "  .github/workflows/ci.yml"
  echo "  .github/workflows/release.yml"

  # Agents
  local agents=(plan-agent research-agent code-review-agent test-runner-agent build-validator-agent code-architect-agent code-simplifier-agent verify-agent)
  echo "  agents/README.md"
  for a in "${agents[@]}"; do
    echo "  agents/$a.md"
  done

  # Tasks
  echo "  tasks/todo.md"
  echo "  tasks/lessons.md"
  echo "  tasks/tests.md"
  echo "  tasks/session.md"

  # Test dirs
  echo "  tests/unit/"
  echo "  tests/integration/"
  echo "  tests/agent/"
  echo "  scratch/.gitkeep"

  # Language-specific files
  local pkg_name="${PROJECT_NAME//-/_}"
  case "$LANGUAGE" in
    python)
      echo "  pyproject.toml"
      echo "  ruff.toml"
      echo "  conftest.py"
      echo "  src/${pkg_name}/__init__.py"
      case "$ARCHETYPE" in
        cli)      echo "  src/${pkg_name}/cli.py"; echo "  src/${pkg_name}/__main__.py" ;;
        api)      echo "  src/${pkg_name}/app.py"; echo "  src/${pkg_name}/routes/health.py" ;;
        library)  echo "  src/${pkg_name}/lib.py" ;;
      esac
      ;;
    typescript)
      echo "  package.json"
      echo "  tsconfig.json"
      echo "  eslint.config.mjs"
      case "$ARCHETYPE" in
        cli)      echo "  src/cli.ts" ;;
        api)      echo "  src/app.ts"; echo "  src/routes/health.ts" ;;
        *)        echo "  src/index.ts" ;;
      esac
      ;;
    go)
      echo "  go.mod"
      case "$ARCHETYPE" in
        api)      echo "  cmd/${PROJECT_NAME}/main.go"; echo "  internal/routes/health.go" ;;
        library)  echo "  ${pkg_name}.go" ;;
        *)        echo "  cmd/${PROJECT_NAME}/main.go" ;;
      esac
      ;;
    rust)
      echo "  Cargo.toml"
      case "$ARCHETYPE" in
        library)  echo "  src/lib.rs" ;;
        *)        echo "  src/main.rs" ;;
      esac
      ;;
  esac

  # Docker
  if [[ "$ENABLE_DOCKER" == true ]]; then
    echo "  Dockerfile"
    echo "  docker-compose.yml"
  fi

  # VS Code
  if [[ "$ENABLE_VSCODE" == true ]]; then
    echo "  .vscode/settings.json"
    echo "  .vscode/extensions.json"
  fi

  # Ralph
  if [[ "$ENABLE_RALPH" == true ]]; then
    echo "  scripts/ralph-loop.sh"
    echo "  PROMPT_build.md"
    echo "  PROMPT_plan.md"
  fi

  echo ""
  echo -e "${GREEN}No files were written. Run without --dry-run to scaffold.${RESET}"
}

# ---------------------------------------------------------------------------
# Step 1: Project basics
# ---------------------------------------------------------------------------
step_project_basics() {
  header "Project Setup"

  local dir_name
  dir_name="$(basename "$SCRIPT_DIR")"

  prompt PROJECT_NAME "Project name" "$dir_name"
  prompt PROJECT_DESC "Short description" "A project built with Claude Code"

  success "Project: $PROJECT_NAME"
}

# ---------------------------------------------------------------------------
# Step 2: Language selection
# ---------------------------------------------------------------------------
step_language() {
  header "Language Selection"

  info "Choose your primary language. This configures:"
  info "  - Language-specific conventions appended to CLAUDE.md"
  info "  - Linter, formatter, type checker, and test runner"
  info "  - Project config files (pyproject.toml, package.json, etc.)"
  echo ""

  prompt_choice LANGUAGE "Select primary language:" \
    "python    â€” pytest, ruff, mypy" \
    "typescript â€” vitest, eslint, tsc" \
    "go        â€” go test, golangci-lint" \
    "rust      â€” cargo test, clippy" \
    "none      â€” language-agnostic (configure later)"

  # Extract just the language name (before the spaces/dash)
  LANGUAGE="${LANGUAGE%% *}"

  if [[ "$LANGUAGE" == "none" ]]; then
    info "No language selected. You can add language support later by copying from templates/."
  else
    success "Language: $LANGUAGE"

    # Show recommendation
    echo ""
    case "$LANGUAGE" in
      python)
        info "${DIM}Recommendation: Use 'uv' or 'pip' with a virtual environment.${RESET}"
        info "${DIM}Run: python -m venv .venv && source .venv/bin/activate && pip install -e '.[dev]'${RESET}"
        ;;
      typescript)
        info "${DIM}Recommendation: Use Node.js 20+ with npm or pnpm.${RESET}"
        info "${DIM}Run: npm install${RESET}"
        ;;
      go)
        info "${DIM}Recommendation: Use Go 1.22+. Install golangci-lint for linting.${RESET}"
        info "${DIM}Run: go mod tidy${RESET}"
        info "${DIM}Note: Update go.mod module path to your full path (e.g., github.com/user/${PROJECT_NAME})${RESET}"
        ;;
      rust)
        info "${DIM}Recommendation: Use the latest stable Rust via rustup.${RESET}"
        info "${DIM}Run: cargo build${RESET}"
        ;;
    esac
  fi
}

# ---------------------------------------------------------------------------
# Step 2b: Project archetype
# ---------------------------------------------------------------------------
step_archetype() {
  # Skip if no language selected â€” archetypes need language context
  if [[ "$LANGUAGE" == "none" ]]; then
    return
  fi

  header "Project Archetype"

  info "Choose an archetype to generate starter project structure."
  info "  This creates entry points, routes, or module layout based on your project type."
  echo ""

  prompt_choice ARCHETYPE "Select project archetype:" \
    "none      â€” blank project (just language tooling)" \
    "cli       â€” command-line tool with argument parsing" \
    "api       â€” web API with routes and health check" \
    "library   â€” reusable library with public API"

  ARCHETYPE="${ARCHETYPE%% *}"

  if [[ "$ARCHETYPE" == "none" ]]; then
    info "No archetype selected. Starting with a blank project."
  else
    success "Archetype: $ARCHETYPE"
  fi
}

# ---------------------------------------------------------------------------
# Step 3: Permissions
# ---------------------------------------------------------------------------
step_permissions() {
  header "Claude Code Permissions"

  info "Safe defaults are always auto-approved:"
  info "  File read/write, searches, git status/diff/log, make targets"
  echo ""
  info "The following need your preference:"
  echo ""

  prompt_yn ALLOW_COMMIT "Auto-approve git commit? (no = Claude asks each time)" true
  prompt_yn ALLOW_PUSH "Auto-approve git push? (no = Claude asks each time)" false
  prompt_yn ALLOW_PKG_MANAGER "Auto-approve package manager commands? (pip/npm/cargo/go)" false
  prompt_yn ALLOW_DOCKER "Auto-approve docker commands?" false

  success "Permissions configured"
}

# ---------------------------------------------------------------------------
# Step 4: Ralph Wiggum
# ---------------------------------------------------------------------------
step_ralph() {
  header "Ralph Wiggum (Autonomous Loop)"

  info "Ralph Wiggum runs Claude Code in iterative cycles:"
  info "  plan â†’ build â†’ test â†’ commit â†’ repeat"
  info "Each iteration gets a fresh context window."
  info "Progress persists via tasks/todo.md."
  echo ""

  prompt_yn ENABLE_RALPH "Enable Ralph Wiggum autonomous loop?" false

  if [[ "$ENABLE_RALPH" == true ]]; then
    success "Ralph Wiggum enabled"
  else
    info "Skipped. You can add Ralph later from templates/ralph/."
  fi
}

step_docker() {
  header "Docker (Optional)"

  prompt_yn ENABLE_DOCKER "Include Dockerfile and docker-compose.yml?" false

  if [[ "$ENABLE_DOCKER" == true ]]; then
    success "Docker enabled"
  else
    info "Skipped. You can add Docker later."
  fi
}

step_vscode() {
  header "VS Code Settings (Optional)"

  prompt_yn ENABLE_VSCODE "Include .vscode/ settings and recommended extensions?" false

  if [[ "$ENABLE_VSCODE" == true ]]; then
    success "VS Code settings enabled"
  else
    info "Skipped. You can add .vscode/ settings later."
  fi
}

# ---------------------------------------------------------------------------
# Step 5: Project planning
# ---------------------------------------------------------------------------
step_planning() {
  header "Project Plan"

  info "A structured plan helps Claude Code understand your project from session one."
  echo ""

  prompt_choice PLAN_CHOICE "How would you like to set up your project plan?" \
    "Build one now   â€” answer a few questions to generate a plan" \
    "Load from file  â€” import an existing plan (markdown)" \
    "Skip            â€” use the blank template"

  PLAN_CHOICE="${PLAN_CHOICE%% *}"

  case "$PLAN_CHOICE" in
    Build)
      build_plan_interactive
      ;;
    Load)
      load_plan_from_file
      ;;
    Skip)
      info "Using blank template. Run '/plan' in Claude Code to create one later."
      local today
      today=$(date +%Y-%m-%d)
      cat > "$SCRIPT_DIR/tasks/todo.md" <<PLAN
# Task Plan â€” ${PROJECT_NAME}

> Created: ${today}
> Status: Not started

## Objective

_Define your project objective here, or run \`/plan\` in Claude Code._

## Plan

- [ ] 1. First task
- [ ] 2. Second task

## Decisions & Context

_Capture architectural decisions and tradeoffs here as you go._

## Results

_Filled in after completion._
PLAN
      ;;
  esac
}

build_plan_interactive() {
  echo ""
  info "Let's build your project plan."
  echo ""

  local objective components milestone risks

  prompt objective "What are you building? (one sentence)" ""
  prompt components "What are the major components or features? (comma-separated)" ""
  prompt milestone "What's the first milestone? (what should work first)" ""
  prompt risks "Any known risks or unknowns?" "None identified yet"

  # Generate structured plan
  local plan_file="$SCRIPT_DIR/tasks/todo.md"
  local today
  today=$(date +%Y-%m-%d)

  cat > "$plan_file" <<PLAN
# Task Plan â€” ${PROJECT_NAME}

> Updated: ${today}
> Branch: \`feat/initial-setup\`
> Status: ðŸŸ¡ Planning

---

## Objective

${objective}

## Plan

PLAN

  # Parse components into checkboxes
  local step=1
  IFS=',' read -ra COMP_ARRAY <<< "$components"
  for comp in "${COMP_ARRAY[@]}"; do
    comp="$(echo "$comp" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
    if [[ -n "$comp" ]]; then
      echo "- [ ] ${step}. ${comp}" >> "$plan_file"
      step=$((step + 1))
    fi
  done

  cat >> "$plan_file" <<PLAN

### Checkpoints

- [ ] **Checkpoint 1**: ${milestone}

## Decisions & Context

_Capture architectural decisions and tradeoffs here as you go._

## Risks

- ${risks}

## Results

_Filled in after completion._
PLAN

  success "Plan written to tasks/todo.md"
}

load_plan_from_file() {
  echo ""
  local plan_path
  prompt plan_path "Path to your plan file" ""

  if [[ -z "$plan_path" ]]; then
    warn "No path provided. Using blank template."
    return
  fi

  # Expand ~ to home directory
  plan_path="${plan_path/#\~/$HOME}"

  if [[ ! -f "$plan_path" ]]; then
    warn "File not found: $plan_path. Using blank template."
    return
  fi

  cp "$plan_path" "$SCRIPT_DIR/tasks/todo.md"
  success "Plan loaded from $plan_path"
}

# ---------------------------------------------------------------------------
# Step 6: Git remote
# ---------------------------------------------------------------------------
step_git_remote() {
  header "Git Remote (Optional)"

  prompt GIT_REMOTE "Git remote URL (leave blank to skip)" ""

  if [[ -n "$GIT_REMOTE" ]]; then
    success "Remote: $GIT_REMOTE"
  fi
}

# ---------------------------------------------------------------------------
# Step 7: GitHub Project Management
# ---------------------------------------------------------------------------
step_github_pm() {
  header "GitHub Project Management"

  info "Issue templates and PR template are included in .github/"

  if [[ -z "$GIT_REMOTE" ]]; then
    info "No git remote set. Run 'make setup-github' when your remote is ready."
    return
  fi

  if ! command -v gh &>/dev/null; then
    info "GitHub CLI (gh) not found. Install it and run 'make setup-github' to set up labels."
    return
  fi

  if ! gh auth status &>/dev/null 2>&1; then
    info "GitHub CLI not authenticated. Run 'gh auth login' then 'make setup-github'."
    return
  fi

  prompt_yn SETUP_LABELS "Create issue labels (type, priority, status)?" true
  prompt_yn SETUP_KANBAN "Create a GitHub Projects kanban board?" false
}

extract_repo_from_remote() {
  local url="$GIT_REMOTE"
  # Handle SSH: git@github.com:user/repo.git
  if [[ "$url" == git@github.com:* ]]; then
    url="${url#git@github.com:}"
    url="${url%.git}"
    echo "$url"
    return
  fi
  # Handle HTTPS: https://github.com/user/repo.git
  if [[ "$url" == https://github.com/* ]]; then
    url="${url#https://github.com/}"
    url="${url%.git}"
    echo "$url"
    return
  fi
  echo ""
}

create_github_labels() {
  info "Creating issue labels..."
  local repo
  repo="$(extract_repo_from_remote)"
  if [[ -z "$repo" ]]; then
    warn "Could not determine GitHub repo from remote URL."
    return
  fi

  # Type labels
  gh label create "bug" --color "d73a4a" --description "Something isn't working" --repo "$repo" --force 2>/dev/null || true
  gh label create "feature" --color "0075ca" --description "New feature or enhancement" --repo "$repo" --force 2>/dev/null || true
  gh label create "task" --color "0e8a16" --description "Development task or chore" --repo "$repo" --force 2>/dev/null || true
  gh label create "chore" --color "e4e669" --description "Maintenance or cleanup" --repo "$repo" --force 2>/dev/null || true
  gh label create "refactor" --color "d4c5f9" --description "Code restructuring, no behavior change" --repo "$repo" --force 2>/dev/null || true

  # Priority labels
  gh label create "P0-critical" --color "b60205" --description "Drop everything" --repo "$repo" --force 2>/dev/null || true
  gh label create "P1-high" --color "d93f0b" --description "Fix this sprint" --repo "$repo" --force 2>/dev/null || true
  gh label create "P2-medium" --color "fbca04" --description "Plan for next sprint" --repo "$repo" --force 2>/dev/null || true
  gh label create "P3-low" --color "c5def5" --description "Nice to have" --repo "$repo" --force 2>/dev/null || true

  # Status labels
  gh label create "needs-triage" --color "f9d0c4" --description "Needs review and prioritization" --repo "$repo" --force 2>/dev/null || true
  gh label create "ready" --color "0e8a16" --description "Ready to be picked up" --repo "$repo" --force 2>/dev/null || true
  gh label create "blocked" --color "b60205" --description "Waiting on external dependency" --repo "$repo" --force 2>/dev/null || true
  gh label create "in-progress" --color "1d76db" --description "Currently being worked on" --repo "$repo" --force 2>/dev/null || true

  success "Labels created (type, priority, status)"
}

create_github_project() {
  info "Creating GitHub Projects kanban board..."
  local repo
  repo="$(extract_repo_from_remote)"
  local owner="${repo%%/*}"

  local project_url
  project_url="$(gh project create --title "${PROJECT_NAME}" --owner "$owner" 2>/dev/null)" || true

  if [[ -n "$project_url" ]]; then
    success "Kanban board created: $project_url"
  else
    warn "Could not create project board. Create one manually at https://github.com/${repo}/projects"
  fi
}

apply_github_pm() {
  if [[ "$SETUP_LABELS" != true && "$SETUP_KANBAN" != true ]]; then
    return
  fi

  header "Setting Up GitHub Project Management"

  # Push to remote first so labels can be created
  if [[ -n "$GIT_REMOTE" ]]; then
    info "Pushing to remote..."
    git -C "$SCRIPT_DIR" push -u origin main 2>/dev/null || true
  fi

  if ! command -v gh &>/dev/null || ! gh auth status &>/dev/null 2>&1; then
    info "GitHub CLI not available. Run 'make setup-github' to create labels and project board."
    return
  fi

  if [[ "$SETUP_LABELS" == true ]]; then
    create_github_labels
  fi

  if [[ "$SETUP_KANBAN" == true ]]; then
    create_github_project
  fi
}

# ---------------------------------------------------------------------------
# Apply: Archetype-specific project structure
# ---------------------------------------------------------------------------
apply_archetype() {
  local escaped_name="$1"
  local pkg_name="${PROJECT_NAME//-/_}"

  info "Creating project structure (archetype: $ARCHETYPE)..."

  case "$LANGUAGE" in
    python)
      mkdir -p "$SCRIPT_DIR/src/$pkg_name"
      touch "$SCRIPT_DIR/src/$pkg_name/__init__.py"

      case "$ARCHETYPE" in
        cli)
          cat > "$SCRIPT_DIR/src/$pkg_name/__main__.py" <<PYEOF
"""Allow running as: python -m $pkg_name"""
from ${pkg_name}.cli import main

if __name__ == "__main__":
    main()
PYEOF
          cat > "$SCRIPT_DIR/src/$pkg_name/cli.py" <<'PYEOF'
"""Command-line interface for {{PROJECT_NAME}}."""
import argparse
import sys


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="{{PROJECT_NAME}}",
        description="{{PROJECT_DESC}}",
    )
    parser.add_argument("--version", action="version", version="%(prog)s 0.1.0")

    subparsers = parser.add_subparsers(dest="command", help="Available commands")

    # Example subcommand â€” replace with your own
    run_parser = subparsers.add_parser("run", help="Run the main task")
    run_parser.add_argument("target", nargs="?", default="world", help="Target to process")

    return parser


def main(argv: list[str] | None = None) -> None:
    parser = build_parser()
    args = parser.parse_args(argv)

    if args.command is None:
        parser.print_help()
        sys.exit(0)

    if args.command == "run":
        print(f"Running with target: {args.target}")
PYEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/$pkg_name/cli.py"
          sed -i "s/{{PROJECT_DESC}}/${PROJECT_DESC//\//\\/}/g" "$SCRIPT_DIR/src/$pkg_name/cli.py"
          success "  Created CLI archetype: src/$pkg_name/cli.py, __main__.py"
          ;;
        api)
          mkdir -p "$SCRIPT_DIR/src/$pkg_name/routes"
          touch "$SCRIPT_DIR/src/$pkg_name/routes/__init__.py"
          cat > "$SCRIPT_DIR/src/$pkg_name/app.py" <<'PYEOF'
"""{{PROJECT_NAME}} â€” API application."""
from http.server import HTTPServer

from {{PKG_NAME}}.routes.health import HealthHandler


def create_app(host: str = "0.0.0.0", port: int = 8000) -> HTTPServer:
    """Create and return the HTTP server."""
    server = HTTPServer((host, port), HealthHandler)
    return server


def main() -> None:
    """Start the development server."""
    server = create_app()
    print(f"Server running on http://localhost:{server.server_address[1]}")
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        print("\nShutting down.")
        server.server_close()


if __name__ == "__main__":
    main()
PYEOF
          cat > "$SCRIPT_DIR/src/$pkg_name/routes/health.py" <<'PYEOF'
"""Health check endpoint."""
import json
from http.server import BaseHTTPRequestHandler


class HealthHandler(BaseHTTPRequestHandler):
    """Handle HTTP requests."""

    def do_GET(self) -> None:
        if self.path == "/health":
            self._json_response(200, {"status": "ok"})
        else:
            self._json_response(404, {"error": "not found"})

    def _json_response(self, status: int, body: dict) -> None:
        self.send_response(status)
        self.send_header("Content-Type", "application/json")
        self.end_headers()
        self.wfile.write(json.dumps(body).encode())
PYEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/$pkg_name/app.py"
          sed -i "s/{{PKG_NAME}}/${pkg_name}/g" "$SCRIPT_DIR/src/$pkg_name/app.py"
          success "  Created API archetype: src/$pkg_name/app.py, routes/health.py"
          ;;
        library)
          cat > "$SCRIPT_DIR/src/$pkg_name/lib.py" <<'PYEOF'
"""{{PROJECT_NAME}} â€” public API."""


def hello(name: str = "world") -> str:
    """Return a greeting. Replace with your library's public API."""
    return f"Hello, {name}!"
PYEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/$pkg_name/lib.py"
          success "  Created library archetype: src/$pkg_name/lib.py"
          ;;
        *)
          success "  Created src/$pkg_name/"
          ;;
      esac
      ;;

    typescript)
      mkdir -p "$SCRIPT_DIR/src"

      case "$ARCHETYPE" in
        cli)
          cat > "$SCRIPT_DIR/src/cli.ts" <<'TSEOF'
/**
 * CLI entry point for {{PROJECT_NAME}}.
 */

interface ParsedArgs {
  command: string | null;
  target: string;
  flags: Record<string, boolean>;
}

function parseArgs(argv: string[]): ParsedArgs {
  const args = argv.slice(2);
  const flags: Record<string, boolean> = {};
  const positional: string[] = [];

  for (const arg of args) {
    if (arg.startsWith("--")) {
      flags[arg.slice(2)] = true;
    } else {
      positional.push(arg);
    }
  }

  return {
    command: positional[0] ?? null,
    target: positional[1] ?? "world",
    flags,
  };
}

function main(): void {
  const { command, target, flags } = parseArgs(process.argv);

  if (flags.version) {
    console.log("{{PROJECT_NAME}} 0.1.0");
    return;
  }

  if (flags.help || command === null) {
    console.log("Usage: {{PROJECT_NAME}} <command> [target]");
    console.log("");
    console.log("Commands:");
    console.log("  run [target]  Run the main task");
    return;
  }

  if (command === "run") {
    console.log(`Running with target: ${target}`);
  }
}

main();
TSEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/cli.ts"
          success "  Created CLI archetype: src/cli.ts"
          ;;
        api)
          mkdir -p "$SCRIPT_DIR/src/routes"
          cat > "$SCRIPT_DIR/src/app.ts" <<'TSEOF'
/**
 * {{PROJECT_NAME}} â€” API application.
 */
import { createServer, IncomingMessage, ServerResponse } from "node:http";
import { healthHandler } from "./routes/health.js";

const PORT = parseInt(process.env.PORT ?? "3000", 10);

function router(req: IncomingMessage, res: ServerResponse): void {
  if (req.url === "/health" && req.method === "GET") {
    healthHandler(req, res);
  } else {
    res.writeHead(404, { "Content-Type": "application/json" });
    res.end(JSON.stringify({ error: "not found" }));
  }
}

const server = createServer(router);

server.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
TSEOF
          cat > "$SCRIPT_DIR/src/routes/health.ts" <<'TSEOF'
/**
 * Health check endpoint.
 */
import { IncomingMessage, ServerResponse } from "node:http";

export function healthHandler(_req: IncomingMessage, res: ServerResponse): void {
  res.writeHead(200, { "Content-Type": "application/json" });
  res.end(JSON.stringify({ status: "ok" }));
}
TSEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/app.ts"
          success "  Created API archetype: src/app.ts, src/routes/health.ts"
          ;;
        library)
          cat > "$SCRIPT_DIR/src/index.ts" <<'TSEOF'
/**
 * {{PROJECT_NAME}} â€” public API.
 */

/**
 * Return a greeting. Replace with your library's public API.
 */
export function hello(name: string = "world"): string {
  return `Hello, ${name}!`;
}
TSEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/index.ts"
          success "  Created library archetype: src/index.ts"
          ;;
        *)
          cat > "$SCRIPT_DIR/src/index.ts" <<'TSEOF'
export function main(): void {
  console.log("Hello from {{PROJECT_NAME}}");
}
TSEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/index.ts"
          success "  Created src/index.ts"
          ;;
      esac
      ;;

    go)
      case "$ARCHETYPE" in
        cli)
          mkdir -p "$SCRIPT_DIR/cmd/$PROJECT_NAME"
          cat > "$SCRIPT_DIR/cmd/$PROJECT_NAME/main.go" <<'GOEOF'
package main

import (
	"fmt"
	"os"
)

func main() {
	if len(os.Args) < 2 {
		printUsage()
		os.Exit(0)
	}

	switch os.Args[1] {
	case "run":
		target := "world"
		if len(os.Args) > 2 {
			target = os.Args[2]
		}
		fmt.Printf("Running with target: %s\n", target)
	case "--version":
		fmt.Println("{{PROJECT_NAME}} 0.1.0")
	case "--help":
		printUsage()
	default:
		fmt.Fprintf(os.Stderr, "Unknown command: %s\n", os.Args[1])
		os.Exit(1)
	}
}

func printUsage() {
	fmt.Println("Usage: {{PROJECT_NAME}} <command> [target]")
	fmt.Println("")
	fmt.Println("Commands:")
	fmt.Println("  run [target]  Run the main task")
}
GOEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/cmd/$PROJECT_NAME/main.go"
          success "  Created CLI archetype: cmd/$PROJECT_NAME/main.go"
          ;;
        api)
          mkdir -p "$SCRIPT_DIR/cmd/$PROJECT_NAME"
          mkdir -p "$SCRIPT_DIR/internal/routes"
          cat > "$SCRIPT_DIR/cmd/$PROJECT_NAME/main.go" <<'GOEOF'
package main

import (
	"fmt"
	"log"
	"net/http"
	"os"

	"{{PROJECT_NAME}}/internal/routes"
)

func main() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	mux := http.NewServeMux()
	mux.HandleFunc("GET /health", routes.HealthHandler)

	fmt.Printf("Server running on http://localhost:%s\n", port)
	log.Fatal(http.ListenAndServe(":"+port, mux))
}
GOEOF
          cat > "$SCRIPT_DIR/internal/routes/health.go" <<'GOEOF'
package routes

import (
	"encoding/json"
	"net/http"
)

// HealthHandler returns the health status of the service.
func HealthHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"status": "ok"})
}
GOEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/cmd/$PROJECT_NAME/main.go"
          success "  Created API archetype: cmd/$PROJECT_NAME/main.go, internal/routes/health.go"
          ;;
        library)
          cat > "$SCRIPT_DIR/${pkg_name}.go" <<'GOEOF'
// Package {{PKG_NAME}} provides the public API.
package {{PKG_NAME}}

// Hello returns a greeting. Replace with your library's public API.
func Hello(name string) string {
	if name == "" {
		name = "world"
	}
	return "Hello, " + name + "!"
}
GOEOF
          sed -i "s/{{PKG_NAME}}/${pkg_name}/g" "$SCRIPT_DIR/${pkg_name}.go"
          success "  Created library archetype: ${pkg_name}.go"
          ;;
        *)
          mkdir -p "$SCRIPT_DIR/cmd/$PROJECT_NAME"
          cat > "$SCRIPT_DIR/cmd/$PROJECT_NAME/main.go" <<'GOEOF'
package main

import "fmt"

func main() {
	fmt.Println("Hello from {{PROJECT_NAME}}")
}
GOEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/cmd/$PROJECT_NAME/main.go"
          success "  Created cmd/$PROJECT_NAME/main.go"
          ;;
      esac
      ;;

    rust)
      mkdir -p "$SCRIPT_DIR/src"

      case "$ARCHETYPE" in
        cli)
          cat > "$SCRIPT_DIR/src/main.rs" <<'RSEOF'
//! CLI entry point for {{PROJECT_NAME}}.
use std::env;
use std::process;

fn main() {
    let args: Vec<String> = env::args().collect();

    if args.len() < 2 {
        print_usage();
        process::exit(0);
    }

    match args[1].as_str() {
        "run" => {
            let target = args.get(2).map(|s| s.as_str()).unwrap_or("world");
            println!("Running with target: {target}");
        }
        "--version" => println!("{{PROJECT_NAME}} 0.1.0"),
        "--help" => print_usage(),
        cmd => {
            eprintln!("Unknown command: {cmd}");
            process::exit(1);
        }
    }
}

fn print_usage() {
    println!("Usage: {{PROJECT_NAME}} <command> [target]");
    println!();
    println!("Commands:");
    println!("  run [target]  Run the main task");
}
RSEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/main.rs"
          success "  Created CLI archetype: src/main.rs"
          ;;
        api)
          cat > "$SCRIPT_DIR/src/main.rs" <<'RSEOF'
//! {{PROJECT_NAME}} â€” API server.
use std::io::Write;
use std::net::TcpListener;

fn main() {
    let port = std::env::var("PORT").unwrap_or_else(|_| "8080".to_string());
    let addr = format!("0.0.0.0:{port}");
    let listener = TcpListener::bind(&addr).expect("Failed to bind");
    println!("Server running on http://localhost:{port}");

    for stream in listener.incoming() {
        if let Ok(mut stream) = stream {
            let response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n{\"status\":\"ok\"}";
            let _ = stream.write_all(response.as_bytes());
        }
    }
}
RSEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/main.rs"
          success "  Created API archetype: src/main.rs"
          ;;
        library)
          cat > "$SCRIPT_DIR/src/lib.rs" <<'RSEOF'
//! {{PROJECT_NAME}} â€” public API.

/// Return a greeting. Replace with your library's public API.
pub fn hello(name: &str) -> String {
    if name.is_empty() {
        return "Hello, world!".to_string();
    }
    format!("Hello, {name}!")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hello_with_name() {
        assert_eq!(hello("Rust"), "Hello, Rust!");
    }

    #[test]
    fn test_hello_empty() {
        assert_eq!(hello(""), "Hello, world!");
    }
}
RSEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/lib.rs"
          # Remove default main.rs for library archetype
          success "  Created library archetype: src/lib.rs"
          ;;
        *)
          cat > "$SCRIPT_DIR/src/main.rs" <<'RSEOF'
fn main() {
    println!("Hello from {{PROJECT_NAME}}");
}
RSEOF
          sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/src/main.rs"
          success "  Created src/main.rs"
          ;;
      esac
      ;;
  esac
}

# ---------------------------------------------------------------------------
# Apply: Template engine
# ---------------------------------------------------------------------------
apply_templates() {
  header "Applying Configuration"

  # --- Append language conventions to CLAUDE.md (before placeholder replacement) ---
  if [[ "$LANGUAGE" != "none" && -f "$SCRIPT_DIR/templates/$LANGUAGE/CONVENTIONS.md" ]]; then
    info "Appending $LANGUAGE conventions to CLAUDE.md..."
    echo "" >> "$SCRIPT_DIR/CLAUDE.md"
    echo "---" >> "$SCRIPT_DIR/CLAUDE.md"
    echo "" >> "$SCRIPT_DIR/CLAUDE.md"
    cat "$SCRIPT_DIR/templates/$LANGUAGE/CONVENTIONS.md" >> "$SCRIPT_DIR/CLAUDE.md"
    success "CLAUDE.md updated with $LANGUAGE conventions"
  fi

  # --- Replace placeholders in CLAUDE.md (after conventions are appended) ---
  info "Customizing CLAUDE.md..."
  local escaped_name escaped_desc
  escaped_name="$(sed_escape "$PROJECT_NAME")"
  escaped_desc="$(sed_escape "$PROJECT_DESC")"
  sed -i "s/{{PROJECT_NAME}}/${escaped_name}/g" "$SCRIPT_DIR/CLAUDE.md"
  sed -i "s/{{PROJECT_DESCRIPTION}}/${escaped_desc}/g" "$SCRIPT_DIR/CLAUDE.md"

  # --- Place language-specific config files ---
  if [[ "$LANGUAGE" != "none" ]]; then
    info "Installing $LANGUAGE config files..."

    local tmpl_dir="$SCRIPT_DIR/templates/$LANGUAGE"

    # Process .tmpl files (replace placeholders, remove .tmpl extension)
    for tmpl in "$tmpl_dir"/*.tmpl; do
      if [[ -f "$tmpl" ]]; then
        local dest_name
        dest_name="$(basename "$tmpl" .tmpl)"
        sed "s/{{PROJECT_NAME}}/${escaped_name}/g; s/{{PROJECT_DESCRIPTION}}/${escaped_desc}/g" \
          "$tmpl" > "$SCRIPT_DIR/$dest_name"
        success "  Created $dest_name"
      fi
    done

    # Copy non-template config files (not CONVENTIONS.md, not .tmpl, not gitignore.append)
    for cfg in "$tmpl_dir"/*; do
      local basename
      basename="$(basename "$cfg")"
      if [[ "$basename" != "CONVENTIONS.md" && \
            "$basename" != "gitignore.append" && \
            "$basename" != *.tmpl && \
            -f "$cfg" ]]; then
        cp "$cfg" "$SCRIPT_DIR/$basename"
        success "  Created $basename"
      fi
    done

    # Append language-specific gitignore entries
    if [[ -f "$tmpl_dir/gitignore.append" ]]; then
      cat "$tmpl_dir/gitignore.append" >> "$SCRIPT_DIR/.gitignore"
      success "  Updated .gitignore with $LANGUAGE entries"
    fi

    # Create src directory + archetype files
    apply_archetype "$escaped_name"
  fi

  # --- Configure permissions ---
  info "Configuring Claude Code permissions..."
  apply_permissions

  # --- Ralph Wiggum ---
  if [[ "$ENABLE_RALPH" == true ]]; then
    info "Setting up Ralph Wiggum..."
    mkdir -p "$SCRIPT_DIR/scripts"
    cp "$SCRIPT_DIR/templates/ralph/ralph-loop.sh" "$SCRIPT_DIR/scripts/ralph-loop.sh"
    chmod +x "$SCRIPT_DIR/scripts/ralph-loop.sh"
    cp "$SCRIPT_DIR/templates/ralph/PROMPT_build.md" "$SCRIPT_DIR/PROMPT_build.md"
    cp "$SCRIPT_DIR/templates/ralph/PROMPT_plan.md" "$SCRIPT_DIR/PROMPT_plan.md"
    success "Ralph Wiggum installed (scripts/ralph-loop.sh)"
  fi

  # --- Generate project README (replaces scaffold README) ---
  info "Generating project README..."
  local getting_started=""
  case "$LANGUAGE" in
    python)
      getting_started="# Set up virtual environment
python -m venv .venv
source .venv/bin/activate
pip install -e '.[dev]'" ;;
    typescript)
      getting_started="# Install dependencies
npm install" ;;
    go)
      getting_started="# Install dependencies
go mod tidy" ;;
    rust)
      getting_started="# Build
cargo build" ;;
    *)
      getting_started="# Install dependencies (configure for your language)" ;;
  esac

  # Build badges line
  local badges=""
  local lang_badge=""
  case "$LANGUAGE" in
    python)     lang_badge="![Python](https://img.shields.io/badge/python-3.12-blue.svg)" ;;
    typescript) lang_badge="![TypeScript](https://img.shields.io/badge/typescript-5.x-blue.svg)" ;;
    go)         lang_badge="![Go](https://img.shields.io/badge/go-1.22-blue.svg)" ;;
    rust)       lang_badge="![Rust](https://img.shields.io/badge/rust-stable-blue.svg)" ;;
  esac
  badges="![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)"
  if [[ -n "$lang_badge" ]]; then
    badges="$badges $lang_badge"
  fi
  if [[ -n "$GIT_REMOTE" ]]; then
    # Extract owner/repo from remote URL for CI badge
    local repo_slug
    repo_slug="$(echo "$GIT_REMOTE" | sed -E 's|.*[:/]([^/]+/[^/]+?)(\.git)?$|\1|')"
    badges="![CI](https://github.com/${repo_slug}/actions/workflows/ci.yml/badge.svg) $badges"
  fi

  cat > "$SCRIPT_DIR/README.md" <<README
# ${PROJECT_NAME}

${badges}

${PROJECT_DESC}

## Getting Started

\`\`\`bash
${getting_started}

# Run tests
make test
\`\`\`

## Development

| Command | Description |
|---------|-------------|
| \`make test\` | Run all test tiers |
| \`make lint\` | Run linter |
| \`make fmt\` | Auto-format code |
| \`make typecheck\` | Run type checker |
| \`make build\` | Compile/build |
| \`make check\` | lint + typecheck + test (pre-PR gate) |

### Claude Code

This project is configured for [Claude Code](https://docs.anthropic.com/en/docs/claude-code) with:

- Agent constitution (\`CLAUDE.md\`)
- 14 slash commands: \`/start\`, \`/plan\`, \`/review\`, \`/test\`, \`/refactor\`, \`/backlog\`, \`/doctor\`, \`/lesson\`, \`/checkpoint\`, \`/status\`, \`/simplify\`, \`/index\`, \`/save\`, \`/load\`
- 8 agent specifications in \`agents/\`
- Task management in \`tasks/\`

## License

[MIT](LICENSE)
README
  success "README.md generated for ${PROJECT_NAME}"

  # --- Generate GETTING_STARTED.md (first-session onboarding guide) ---
  info "Generating getting started guide..."
  local env_setup=""
  case "$LANGUAGE" in
    python)
      env_setup="### Set Up Your Environment

\`\`\`bash
python -m venv .venv
source .venv/bin/activate
pip install -e '.[dev]'
\`\`\`" ;;
    typescript)
      env_setup="### Set Up Your Environment

\`\`\`bash
npm install
\`\`\`" ;;
    go)
      env_setup="### Set Up Your Environment

\`\`\`bash
go mod tidy
\`\`\`" ;;
    rust)
      env_setup="### Set Up Your Environment

\`\`\`bash
cargo build
\`\`\`" ;;
    *)
      env_setup="### Set Up Your Environment

Install dependencies for your chosen language, then come back here." ;;
  esac

  cat > "$SCRIPT_DIR/GETTING_STARTED.md" <<GUIDE
# Getting Started with ${PROJECT_NAME}

Welcome! This guide walks you through your first 10 minutes with Claude Code.

## Step 1: Set Up

${env_setup}

## Step 2: Launch Claude Code

\`\`\`bash
claude
\`\`\`

## Step 3: Start Building

The easiest way to get going is to type:

\`\`\`
/start
\`\`\`

This will walk you through creating your first plan and (optionally) your first GitHub issue.

**Or, if you already know what you want to build**, just tell Claude:

\`\`\`
I want to build [your idea here]. Help me create a plan.
\`\`\`

Claude will create a structured plan in \`tasks/todo.md\` and ask for your approval before writing any code.

## Step 4: Build

Once your plan is approved, tell Claude to start:

\`\`\`
Let's start on step 1.
\`\`\`

Claude will work through the plan step by step, committing as it goes. You stay in control â€” it will check in at each step.

## Your Toolkit

Here are the commands you'll use most:

| Command | What It Does | When to Use It |
|---------|-------------|----------------|
| \`/start\` | Guided first-session setup | Right now (first time only) |
| \`/plan\` | Create or refine a project plan | Starting a new feature or task |
| \`/status\` | See progress and what's next | Any time you lose track |
| \`/backlog show\` | See open GitHub issues by priority | Picking what to work on |
| \`/backlog pick #N\` | Start working on issue #N | Beginning a task |
| \`/checkpoint\` | Commit progress and update plan | After completing a step |
| \`/test\` | Run tests and analyze results | Before committing |
| \`/save\` | Save session state for later | Ending a session |
| \`/load\` | Restore previous session context | Starting a new session |
| \`/lesson\` | Record what you learned | After fixing a tricky bug |

## How It Works

Your project has a few key files that Claude reads automatically:

- **\`CLAUDE.md\`** â€” The "rules" for how Claude works in your project (commit conventions, testing requirements, safety guardrails)
- **\`tasks/todo.md\`** â€” Your current plan and progress
- **\`tasks/lessons.md\`** â€” Things Claude learned from past sessions (mistakes to avoid, patterns that work)

You don't need to read these files â€” Claude uses them behind the scenes. But feel free to peek if you're curious.

## Tips

- **Be specific.** "Build a REST API for managing todos with CRUD endpoints" works better than "build something."
- **Let Claude plan first.** It will create a step-by-step plan before writing code. Review and approve it.
- **Commit often.** Use \`/checkpoint\` after each working piece. Small commits are easier to review and revert.
- **Ask questions.** Claude will ask you when it needs clarification. You can also ask it anything about the code.
GUIDE
  success "GETTING_STARTED.md generated"

  # --- Generate CI workflow ---
  info "Generating CI workflow..."
  mkdir -p "$SCRIPT_DIR/.github/workflows"

  local ci_setup=""
  local ci_lang_name=""
  case "$LANGUAGE" in
    python)
      ci_lang_name="Python"
      ci_setup="
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: |
          python -m venv .venv
          source .venv/bin/activate
          pip install -e '.[dev]'" ;;
    typescript)
      ci_lang_name="TypeScript"
      ci_setup="
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci" ;;
    go)
      ci_lang_name="Go"
      ci_setup="
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'" ;;
    rust)
      ci_lang_name="Rust"
      ci_setup="
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt" ;;
    *)
      ci_lang_name="Generic"
      ci_setup="" ;;
  esac

  cat > "$SCRIPT_DIR/.github/workflows/ci.yml" <<CIEOF
name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]

jobs:
  check:
    name: Lint, typecheck, and test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
${ci_setup}

      - name: Run checks
        run: make check
CIEOF
  success "CI workflow generated (.github/workflows/ci.yml)"

  # --- Generate .env.example ---
  info "Generating .env.example..."
  cat > "$SCRIPT_DIR/.env.example" <<'ENVEOF'
# Environment variables for this project
# Copy to .env and fill in values: cp .env.example .env
# NEVER commit .env â€” it's in .gitignore

# Example:
# DATABASE_URL=postgresql://localhost:5432/mydb
# API_KEY=your-api-key-here
ENVEOF
  success ".env.example generated"

  # --- Generate CHANGELOG.md ---
  info "Generating CHANGELOG.md..."
  cat > "$SCRIPT_DIR/CHANGELOG.md" <<CHLOG
# Changelog

All notable changes to ${PROJECT_NAME} will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/),
and this project adheres to [Semantic Versioning](https://semver.org/).

## [Unreleased]

### Added
- Initial project setup with scaffold framework
CHLOG
  success "CHANGELOG.md generated"

  # --- Generate SECURITY.md ---
  info "Generating SECURITY.md..."
  cat > "$SCRIPT_DIR/SECURITY.md" <<'SECEOF'
# Security Policy

## Supported Versions

| Version | Supported |
|---------|-----------|
| latest  | Yes       |

## Reporting a Vulnerability

If you discover a security vulnerability, please report it responsibly:

1. **Do not** open a public GitHub issue
2. Email the maintainers or use [GitHub's private vulnerability reporting](https://docs.github.com/en/code-security/security-advisories/guidance-on-reporting-and-writing-information-about-vulnerabilities/privately-reporting-a-security-vulnerability)
3. Include a description of the vulnerability, steps to reproduce, and potential impact
4. Allow up to 72 hours for an initial response

## Scope

This policy applies to the latest version of this project. We take all security reports seriously and will investigate promptly.

## Disclosure

We follow coordinated disclosure. We will work with you to understand and address the issue before any public disclosure.
SECEOF
  success "SECURITY.md generated"

  # --- Generate pre-commit config ---
  info "Generating pre-commit config..."
  local precommit_hooks=""
  case "$LANGUAGE" in
    python)
      precommit_hooks="  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.4.4
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format" ;;
    typescript)
      precommit_hooks="  - repo: local
    hooks:
      - id: eslint
        name: eslint
        entry: npx eslint --fix
        language: system
        types: [ts, tsx, js, jsx]" ;;
    go)
      precommit_hooks="  - repo: https://github.com/golangci/golangci-lint
    rev: v1.59.0
    hooks:
      - id: golangci-lint" ;;
    rust)
      precommit_hooks="  - repo: local
    hooks:
      - id: cargo-fmt
        name: cargo fmt
        entry: cargo fmt --
        language: system
        types: [rust]
      - id: cargo-clippy
        name: cargo clippy
        entry: cargo clippy -- -D warnings
        language: system
        types: [rust]
        pass_filenames: false" ;;
    *)
      precommit_hooks="" ;;
  esac

  cat > "$SCRIPT_DIR/.pre-commit-config.yaml" <<PCEOF
# Pre-commit hooks â€” run automatically before each commit
# Install: pip install pre-commit && pre-commit install
# Manual run: pre-commit run --all-files
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.6.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
        args: ['--maxkb=500']
      - id: detect-private-key
      - id: check-merge-conflict
${precommit_hooks}
  - repo: https://github.com/Yelp/detect-secrets
    rev: v1.5.0
    hooks:
      - id: detect-secrets
        args: ['--baseline', '.secrets.baseline']
PCEOF
  success "Pre-commit config generated (.pre-commit-config.yaml)"

  # --- Generate Docker files (if enabled) ---
  if [[ "$ENABLE_DOCKER" == true ]]; then
    info "Generating Docker files..."

    case "$LANGUAGE" in
      python)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM python:3.12-slim AS base

WORKDIR /app

COPY pyproject.toml ./
RUN pip install --no-cache-dir .

COPY src/ ./src/

EXPOSE 8000
CMD ["python", "-m", "uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
DKEOF
        ;;
      typescript)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM node:20-alpine AS builder

WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine
WORKDIR /app
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/package*.json ./

EXPOSE 3000
CMD ["node", "dist/index.js"]
DKEOF
        ;;
      go)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM golang:1.22-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY . .
RUN CGO_ENABLED=0 go build -o /bin/app ./cmd/

FROM alpine:3.19
RUN apk add --no-cache ca-certificates
COPY --from=builder /bin/app /bin/app

EXPOSE 8080
CMD ["/bin/app"]
DKEOF
        ;;
      rust)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM rust:1.78-slim AS builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
RUN mkdir src && echo "fn main() {}" > src/main.rs && cargo build --release && rm -rf src
COPY src/ ./src/
RUN touch src/main.rs && cargo build --release

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y --no-install-recommends ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/app /usr/local/bin/app

EXPOSE 8080
CMD ["app"]
DKEOF
        ;;
      *)
        cat > "$SCRIPT_DIR/Dockerfile" <<'DKEOF'
FROM ubuntu:22.04

WORKDIR /app
COPY . .

# Configure for your language
# RUN apt-get update && apt-get install -y ...

EXPOSE 8080
CMD ["echo", "Configure this Dockerfile for your project"]
DKEOF
        ;;
    esac

    cat > "$SCRIPT_DIR/docker-compose.yml" <<DCEOF
services:
  app:
    build: .
    ports:
      - "8080:8080"
    env_file:
      - .env
    volumes:
      - .:/app
    # Uncomment for development with hot reload:
    # command: ["your-dev-command-here"]

  # Add services as needed:
  # db:
  #   image: postgres:16-alpine
  #   environment:
  #     POSTGRES_DB: ${PROJECT_NAME}
  #     POSTGRES_USER: postgres
  #     POSTGRES_PASSWORD: postgres
  #   ports:
  #     - "5432:5432"
  #   volumes:
  #     - db_data:/var/lib/postgresql/data

# volumes:
#   db_data:
DCEOF
    success "Docker files generated (Dockerfile, docker-compose.yml)"
  fi

  # --- Generate VS Code settings ---
  if [[ "$ENABLE_VSCODE" == true ]]; then
    info "Generating VS Code settings..."
    mkdir -p "$SCRIPT_DIR/.vscode"

    # settings.json â€” per language
    local vscode_settings=""
    case "$LANGUAGE" in
      python)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [88],
  "editor.tabSize": 4,
  "[python]": {
    "editor.defaultFormatter": "charliermarsh.ruff",
    "editor.codeActionsOnSave": {
      "source.fixAll.ruff": "explicit",
      "source.organizeImports.ruff": "explicit"
    }
  },
  "python.testing.pytestEnabled": true,
  "python.testing.pytestArgs": ["tests"]
}' ;;
      typescript)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [100],
  "editor.tabSize": 2,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "[typescriptreact]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "typescript.preferences.importModuleSpecifier": "relative"
}' ;;
      go)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [100],
  "editor.tabSize": 4,
  "[go]": {
    "editor.defaultFormatter": "golang.go"
  },
  "go.lintTool": "golangci-lint",
  "go.lintOnSave": "workspace",
  "go.testFlags": ["-v"]
}' ;;
      rust)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [100],
  "editor.tabSize": 4,
  "[rust]": {
    "editor.defaultFormatter": "rust-lang.rust-analyzer"
  },
  "rust-analyzer.check.command": "clippy"
}' ;;
      *)
        vscode_settings='{
  "editor.formatOnSave": true,
  "editor.rulers": [100],
  "editor.tabSize": 2
}' ;;
    esac
    echo "$vscode_settings" > "$SCRIPT_DIR/.vscode/settings.json"

    # extensions.json â€” per language
    local vscode_extensions=""
    case "$LANGUAGE" in
      python)
        vscode_extensions='{
  "recommendations": [
    "charliermarsh.ruff",
    "ms-python.python",
    "ms-python.vscode-pylance"
  ]
}' ;;
      typescript)
        vscode_extensions='{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode"
  ]
}' ;;
      go)
        vscode_extensions='{
  "recommendations": [
    "golang.go"
  ]
}' ;;
      rust)
        vscode_extensions='{
  "recommendations": [
    "rust-lang.rust-analyzer"
  ]
}' ;;
      *)
        vscode_extensions='{
  "recommendations": []
}' ;;
    esac
    echo "$vscode_extensions" > "$SCRIPT_DIR/.vscode/extensions.json"

    success "VS Code settings generated (.vscode/)"
  fi

  # --- Generate release workflow ---
  info "Generating release workflow..."
  cat > "$SCRIPT_DIR/.github/workflows/release.yml" <<'RLEOF'
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract changelog for this version
        id: changelog
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          # Extract section for this version from CHANGELOG.md
          NOTES=$(awk "/^## \[${VERSION}\]/{flag=1; next} /^## \[/{flag=0} flag" CHANGELOG.md)
          if [ -z "$NOTES" ]; then
            NOTES="Release ${GITHUB_REF_NAME}"
          fi
          {
            echo 'notes<<EOF'
            echo "$NOTES"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ github.token }}
          TAG_NAME: ${{ github.ref_name }}
          RELEASE_NOTES: ${{ steps.changelog.outputs.notes }}
        run: |
          gh release create "$TAG_NAME" \
            --title "$TAG_NAME" \
            --notes "$RELEASE_NOTES"
RLEOF
  success "Release workflow generated (.github/workflows/release.yml)"
}

apply_permissions() {
  local settings="$SCRIPT_DIR/.claude/settings.json"
  local tmp_settings
  tmp_settings=$(mktemp)

  # Start with existing settings and add user-chosen permissions
  cp "$settings" "$tmp_settings"

  # Build the additional allow rules
  local additions=""

  if [[ "$ALLOW_COMMIT" == true ]]; then
    additions="$additions\"Bash(git commit *)\", \"Bash(git commit -m *)\", "
  fi

  if [[ "$ALLOW_PUSH" == true ]]; then
    additions="$additions\"Bash(git push *)\", \"Bash(git push)\", "
  fi

  if [[ "$ALLOW_PKG_MANAGER" == true ]]; then
    case "$LANGUAGE" in
      python)    additions="$additions\"Bash(pip install *)\", \"Bash(pip install)\", \"Bash(uv *)\", " ;;
      typescript) additions="$additions\"Bash(npm install *)\", \"Bash(npm install)\", \"Bash(npm ci)\", \"Bash(npx *)\", " ;;
      go)        additions="$additions\"Bash(go get *)\", \"Bash(go mod *)\", " ;;
      rust)      additions="$additions\"Bash(cargo build *)\", \"Bash(cargo add *)\", " ;;
      none)      additions="$additions\"Bash(pip install *)\", \"Bash(npm install *)\", \"Bash(go get *)\", \"Bash(cargo add *)\", " ;;
    esac
  fi

  if [[ "$ALLOW_DOCKER" == true ]]; then
    additions="$additions\"Bash(docker build *)\", \"Bash(docker compose *)\", \"Bash(docker run *)\", "
  fi

  # If we have additions, insert them into the allow array
  if [[ -n "$additions" ]]; then
    # Remove trailing comma+space
    additions="${additions%, }"
    # Insert after the last existing allow entry (before the closing bracket)
    # Use python/sed to safely modify JSON... but we're zero-dependency bash.
    # Simple approach: replace the last entry in allow array with itself + new entries
    local last_allow
    last_allow=$(grep -n '"Bash(mkdir \*)' "$tmp_settings" | tail -1 | cut -d: -f1)
    if [[ -n "$last_allow" ]]; then
      sed -i "${last_allow}s|\"Bash(mkdir \*)\"|\"Bash(mkdir *)\",\n      ${additions}|" "$tmp_settings"
    fi
  fi

  cp "$tmp_settings" "$settings"
  rm -f "$tmp_settings"
  success "  Permissions updated in .claude/settings.json"
}

# ---------------------------------------------------------------------------
# Cleanup: Remove scaffold artifacts
# ---------------------------------------------------------------------------
cleanup_artifacts() {
  if [[ "$KEEP_ARTIFACTS" == true ]]; then
    info "Keeping scaffold artifacts (--keep flag)."
    return
  fi

  header "Cleaning Up"

  info "Removing scaffold artifacts..."
  rm -rf "$SCRIPT_DIR/templates"
  success "  Removed templates/"

  # Remove this script last
  local self="$SCRIPT_DIR/scaffold"
  if [[ -f "$self" ]]; then
    rm "$self"
    success "  Removed scaffold"
  fi

  success "Project is clean â€” no scaffold artifacts remain."
}

# ---------------------------------------------------------------------------
# Git initialization
# ---------------------------------------------------------------------------
init_git() {
  header "Git Initialization"

  # If cloned from scaffold repo, remove the cloned .git to start fresh
  if [[ -d "$SCRIPT_DIR/.git" ]]; then
    local remote_url
    remote_url="$(git -C "$SCRIPT_DIR" remote get-url origin 2>/dev/null || echo "")"
    if [[ "$remote_url" == *"sakebomb/scaffold"* ]]; then
      info "Removing cloned scaffold git history..."
      rm -rf "$SCRIPT_DIR/.git"
    fi
  fi

  # Initialize or verify git repo
  if [[ -d "$SCRIPT_DIR/.git" ]]; then
    info "Git repo already exists."
  else
    info "Initializing git repository..."
    git -C "$SCRIPT_DIR" init -b main
    success "Git repo initialized (main branch)"
  fi

  # Add remote if provided
  if [[ -n "$GIT_REMOTE" ]]; then
    git -C "$SCRIPT_DIR" remote add origin "$GIT_REMOTE" 2>/dev/null || \
      git -C "$SCRIPT_DIR" remote set-url origin "$GIT_REMOTE"
    success "Remote set: $GIT_REMOTE"
  fi

  # Stage and commit
  info "Creating initial commit..."
  git -C "$SCRIPT_DIR" add -A
  git -C "$SCRIPT_DIR" commit -m "$(cat <<'EOF'
feat: initialize project with scaffold framework

- CLAUDE.md agent constitution with project conventions
- .claude/ settings, skills (slash commands), and hooks
- Tiered test structure (unit/integration/agent)
- Task management (todo, lessons, tests)
- Agent specifications
- Language-aware Makefile

Scaffolded with https://github.com/sakebomb/scaffold
EOF
  )"
  success "Initial commit created"

  # Show status
  echo ""
  info "Branch: $(git -C "$SCRIPT_DIR" rev-parse --abbrev-ref HEAD)"
  info "Commits: $(git -C "$SCRIPT_DIR" rev-list --count HEAD)"
}

# ---------------------------------------------------------------------------
# Summary
# ---------------------------------------------------------------------------
show_summary() {
  header "Setup Complete"

  echo -e "${GREEN}Your project '${PROJECT_NAME}' is ready for Claude Code.${RESET}"
  echo ""
  echo "What's configured:"
  echo -e "  ${BOLD}CLAUDE.md${RESET}           Agent constitution + conventions"
  echo -e "  ${BOLD}.claude/settings${RESET}    Tiered permissions"
  echo -e "  ${BOLD}.claude/skills/${RESET}     14 slash commands (/start, /plan, /backlog, /save, /load, ...)"
  echo -e "  ${BOLD}.claude/hooks/${RESET}      Main branch protection"
  echo -e "  ${BOLD}.github/${RESET}            Issue templates, PR template, CI workflow"
  echo -e "  ${BOLD}agents/${RESET}             8 agent specifications"
  echo -e "  ${BOLD}tasks/${RESET}              Plan, lessons, test registry"
  echo -e "  ${BOLD}Makefile${RESET}            test, lint, fmt, typecheck, build, check, setup, setup-github"
  echo -e "  ${BOLD}.pre-commit${RESET}         Linting + secret scanning on commit"

  if [[ "$LANGUAGE" != "none" ]]; then
    echo -e "  ${BOLD}Language${RESET}            $LANGUAGE (conventions, configs, tooling)"
  fi

  if [[ "$ENABLE_DOCKER" == true ]]; then
    echo -e "  ${BOLD}Docker${RESET}              Dockerfile + docker-compose.yml"
  fi

  if [[ "$ENABLE_RALPH" == true ]]; then
    echo -e "  ${BOLD}Ralph Wiggum${RESET}       scripts/ralph-loop.sh (autonomous loop)"
  fi

  echo ""
  echo "Next steps:"
  echo "  1. cd $(basename "$SCRIPT_DIR")"
  echo "  2. Bootstrap dev environment: make setup"
  echo "  3. Start Claude Code: claude"
  echo "  4. Type: /start"
  echo ""
  echo -e "  ${DIM}Or skip /start and just tell Claude what to build:${RESET}"
  echo "  \"I want to build [your idea]. Help me create a plan.\""

  if [[ "$ENABLE_RALPH" == true ]]; then
    echo ""
    echo "  Ralph Wiggum (autonomous loop):"
    echo "  ./scripts/ralph-loop.sh plan   â€” autonomous planning"
    echo "  ./scripts/ralph-loop.sh build  â€” autonomous building"
  fi

  echo ""
  echo -e "  ${DIM}Full walkthrough: GETTING_STARTED.md${RESET}"
  echo ""
}

# ---------------------------------------------------------------------------
# Add language mode â€” layer a second language into existing project
# ---------------------------------------------------------------------------
run_add_language() {
  local lang="$ADD_LANGUAGE"

  header "Adding $lang to existing project"

  # Validate project has been scaffolded already
  if [[ ! -f "$SCRIPT_DIR/CLAUDE.md" ]]; then
    error "No CLAUDE.md found. Run ./scaffold first to initialize the project."
    exit 1
  fi

  if [[ ! -d "$SCRIPT_DIR/templates/$lang" ]]; then
    error "Templates for $lang not found. Make sure scaffold templates are present (use --keep on initial run)."
    exit 1
  fi

  # --- Append language conventions to CLAUDE.md (skip if already present) ---
  local convention_header=""
  case "$lang" in
    python)     convention_header="Python Conventions" ;;
    typescript) convention_header="TypeScript Conventions" ;;
    go)         convention_header="Go Conventions" ;;
    rust)       convention_header="Rust Conventions" ;;
  esac

  if grep -q "$convention_header" "$SCRIPT_DIR/CLAUDE.md" 2>/dev/null; then
    info "$convention_header already in CLAUDE.md â€” skipping"
  elif [[ -f "$SCRIPT_DIR/templates/$lang/CONVENTIONS.md" ]]; then
    info "Appending $lang conventions to CLAUDE.md..."
    echo "" >> "$SCRIPT_DIR/CLAUDE.md"
    echo "---" >> "$SCRIPT_DIR/CLAUDE.md"
    echo "" >> "$SCRIPT_DIR/CLAUDE.md"
    cat "$SCRIPT_DIR/templates/$lang/CONVENTIONS.md" >> "$SCRIPT_DIR/CLAUDE.md"
    success "CLAUDE.md updated with $lang conventions"
  fi

  # --- Install language config files (don't overwrite existing) ---
  info "Installing $lang config files..."
  local tmpl_dir="$SCRIPT_DIR/templates/$lang"

  # Detect project name from existing CLAUDE.md or directory name
  PROJECT_NAME="${PROJECT_NAME:-$(basename "$SCRIPT_DIR")}"
  PROJECT_DESC="${PROJECT_DESC:-A project built with Claude Code}"
  local escaped_name escaped_desc
  escaped_name="$(sed_escape "$PROJECT_NAME")"
  escaped_desc="$(sed_escape "$PROJECT_DESC")"

  # Process .tmpl files (skip if target exists)
  for tmpl in "$tmpl_dir"/*.tmpl; do
    if [[ -f "$tmpl" ]]; then
      local dest_name
      dest_name="$(basename "$tmpl" .tmpl)"
      if [[ -f "$SCRIPT_DIR/$dest_name" ]]; then
        info "  Skipping $dest_name (already exists)"
      else
        sed "s/{{PROJECT_NAME}}/${escaped_name}/g; s/{{PROJECT_DESCRIPTION}}/${escaped_desc}/g" \
          "$tmpl" > "$SCRIPT_DIR/$dest_name"
        success "  Created $dest_name"
      fi
    fi
  done

  # Copy non-template config files (skip if target exists)
  for cfg in "$tmpl_dir"/*; do
    local basename
    basename="$(basename "$cfg")"
    if [[ "$basename" != "CONVENTIONS.md" && \
          "$basename" != "gitignore.append" && \
          "$basename" != *.tmpl && \
          -f "$cfg" ]]; then
      if [[ -f "$SCRIPT_DIR/$basename" ]]; then
        info "  Skipping $basename (already exists)"
      else
        cp "$cfg" "$SCRIPT_DIR/$basename"
        success "  Created $basename"
      fi
    fi
  done

  # --- Append to .gitignore (don't duplicate entries) ---
  if [[ -f "$tmpl_dir/gitignore.append" ]]; then
    info "Updating .gitignore with $lang entries..."
    while IFS= read -r line; do
      if [[ -n "$line" && "$line" != \#* ]]; then
        if ! grep -qxF "$line" "$SCRIPT_DIR/.gitignore" 2>/dev/null; then
          echo "$line" >> "$SCRIPT_DIR/.gitignore"
        fi
      elif [[ "$line" == \#* ]]; then
        # Add comment headers if not already present
        if ! grep -qxF "$line" "$SCRIPT_DIR/.gitignore" 2>/dev/null; then
          echo "$line" >> "$SCRIPT_DIR/.gitignore"
        fi
      fi
    done < "$tmpl_dir/gitignore.append"
    success "  .gitignore updated"
  fi

  # --- Add prefixed Makefile targets ---
  info "Adding $lang Makefile targets..."
  local lang_short=""
  local test_cmd="" lint_cmd="" fmt_cmd="" typecheck_cmd=""
  case "$lang" in
    python)
      lang_short="py"
      test_cmd="python -m pytest tests/ -v"
      lint_cmd="ruff check ."
      fmt_cmd="ruff format ."
      typecheck_cmd="mypy src/"
      ;;
    typescript)
      lang_short="ts"
      test_cmd="npx vitest run"
      lint_cmd="npx eslint src/"
      fmt_cmd="npx prettier --write src/"
      typecheck_cmd="npx tsc --noEmit"
      ;;
    go)
      lang_short="go"
      test_cmd="go test ./..."
      lint_cmd="golangci-lint run"
      fmt_cmd="gofmt -w ."
      typecheck_cmd="go vet ./..."
      ;;
    rust)
      lang_short="rs"
      test_cmd="cargo test"
      lint_cmd="cargo clippy -- -D warnings"
      fmt_cmd="cargo fmt"
      typecheck_cmd="cargo check"
      ;;
  esac

  if grep -q "^test-${lang_short}:" "$SCRIPT_DIR/Makefile" 2>/dev/null; then
    info "  Makefile targets for $lang already exist â€” skipping"
  else
    cat >> "$SCRIPT_DIR/Makefile" <<MKEOF

# --- ${lang} targets (added via --add) ---
.PHONY: test-${lang_short} lint-${lang_short} fmt-${lang_short} typecheck-${lang_short}

test-${lang_short}:
	${test_cmd}

lint-${lang_short}:
	${lint_cmd}

fmt-${lang_short}:
	${fmt_cmd}

typecheck-${lang_short}:
	${typecheck_cmd}
MKEOF
    success "  Added test-${lang_short}, lint-${lang_short}, fmt-${lang_short}, typecheck-${lang_short}"
  fi

  # --- Update CI workflow to include second language ---
  local ci_file="$SCRIPT_DIR/.github/workflows/ci.yml"
  if [[ -f "$ci_file" ]]; then
    if grep -q "$lang" "$ci_file" 2>/dev/null; then
      info "  CI already references $lang â€” skipping"
    else
      info "Updating CI workflow for $lang..."
      local ci_step=""
      case "$lang" in
        python) ci_step="
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Python dependencies
        run: |
          python -m venv .venv
          source .venv/bin/activate
          pip install -e '.[dev]'

      - name: Run Python checks
        run: make test-py && make lint-py" ;;
        typescript) ci_step="
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install TypeScript dependencies
        run: npm ci

      - name: Run TypeScript checks
        run: make test-ts && make lint-ts" ;;
        go) ci_step="
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'

      - name: Run Go checks
        run: make test-go && make lint-go" ;;
        rust) ci_step="
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy, rustfmt

      - name: Run Rust checks
        run: make test-rs && make lint-rs" ;;
      esac

      # Insert new language steps before the final "Run checks" step
      if [[ -n "$ci_step" ]]; then
        local ci_tmp
        ci_tmp="$(mktemp)"
        awk -v steps="$ci_step" '
          /- name: Run checks/ { print steps; print ""; }
          { print }
        ' "$ci_file" > "$ci_tmp"
        mv "$ci_tmp" "$ci_file"
        success "  CI workflow updated with $lang steps"
      fi
    fi
  fi

  echo ""
  success "Successfully added $lang to your project."
  info "Review changes with: git diff"
  info "New Makefile targets: test-${lang_short}, lint-${lang_short}, fmt-${lang_short}, typecheck-${lang_short}"
}

# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------
main() {
  parse_flags "$@"

  # --add mode: layer a second language and exit
  if [[ -n "$ADD_LANGUAGE" ]]; then
    run_add_language
    exit 0
  fi

  echo ""
  echo -e "${BOLD}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${RESET}"
  echo -e "${BOLD}â•‘          Scaffold â€” Claude Code Setup            â•‘${RESET}"
  echo -e "${BOLD}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${RESET}"

  step_project_basics
  step_language
  step_archetype
  step_permissions
  step_ralph
  step_docker
  step_vscode
  step_planning
  step_git_remote
  step_github_pm

  # Dry-run: show preview and exit without writing anything
  if [[ "$DRY_RUN" == true ]]; then
    dry_run_report
    exit 0
  fi

  # Snapshot existing files and enable rollback on failure
  snapshot_pre_existing
  trap rollback_on_failure ERR

  apply_templates
  cleanup_artifacts
  init_git
  apply_github_pm

  # Disable rollback trap â€” we succeeded
  trap - ERR
  rm -f "$PRE_SNAPSHOT"

  show_summary
}

main "$@"
